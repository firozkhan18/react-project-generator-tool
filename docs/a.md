hey guys welcome to concept and coding and this is Shan and today we are going to start multi-threading and these are the list of subtopics which I have come up with so I'll go with this list itself so that we don't miss any Topic in the multi-threading and concurrency right uh don't worry I will post this uh the list into the description section so you can refer it and I'll complete this in uh part so in today's part I will cover this two so this this is the part one video of it okay so let's start our multi-threading and concurrency part one okay so introduction of multi-threading so before we talk about multi-threading right or what are the different threads and all we have to first understand what is thread and what is process this is one of the most asked interview Cod question and don't underestimate this question because I have seen many good Engineers getting stuck into this question right because there are so many follow-up questions can come into this and at one point engineer do get stuck as this is very very important questions and lot of Logics are building around it right so let's see that how actually they are differs and how they are actually related what is thread and process so it just look at this diagram you will get one glance that okay we have a process and inside a process we have multiple threats right and that's where you will find the definition across all over the Internet that processes instance of a program that is getting executed yeah let's read it again process is is an inst chance of a program that is getting executed now what does it mean okay what what do you mean by that program that is getting executed is called process I'll tell you what does it mean suppose that you have a you have one Java file test. Java this has your public static public static void main is string args right and you have your code now now what the first thing you have to do if to have to run it you have to do compile it you have to do Java C test. Java right the first step compilation Java C test. Java what it will do it will generate the bite code that can be executed by the jvm now it the bite code which is generated by it now we have to execute it how we will execute it we you we have to run it like Java test right when we do executed what we will do jvm starts the new process at this point of time so that's why the name or you can say the definition of process says that it is an instance of a program that is getting executed so now here if you see we are executing our program we are executing our program after we execute It Whatever the output has to become you will show into the console right so whenever you are doing execution your program at that point jvm starts the new process right and that's how generally the definition we says that a program that is getting executed is known as process but generally it is not known as process it is generally at that time process is created right so there are lot of things is required when a program is getting executed it required lot of resources like memory and all right so process provide all these things right so we will see uh soon at that point also so this first step is clear right process is an instance of a program that is getting executed second it has its own resource like memory thread Etc OS allocate this resources to process when it is created so I told you right to execute a program it required a lot of resources like memory so OS takes care of allocating this resources to process so now what happen is okay you are executing a program jvm creates a process right I have a process one this process requires certain resources like memory also so what happen is it has its own memory let's say Heap memory so when let's say another process is getting created process two it has its own memory its Heap memory right so there these two process are totally independent of each other they have their own memory right and they don't like you can say that they don't disturb each other they can run parall right they are to independent of each other I know that at this point of time there are lot of questions coming into our mind that hey how this process have their own Heap memory because we understand that jvm has their own one Heap memory jvm has Heap memory it also maintain a stack right now how this process have their own Heap memory don't worry I will come to everything I know this is where it all things get messy right right but we are taking a baby step first you need to understand what is process so process means whenever you execute a program a process is created each time a process is created it has allocated its own resources they never share two process never share resources to each other they have their own resources and they can run parall okay so we have this basic understanding of process don't worry about this I will come to this later now what is thread okay I understand very basic of process now now can you tell me like what is thread with this diagram with this diagram we can tell that one process can have multiple threads right okay that's right one process can have multiple threat but thread is also known as lightweight process but what does it mean it means the smallest sequence of instructions that are executed by CPU independently right so whenever we have so what does process do process like it is converted the bite code into machine code right you have converted the bite code into machine code now this machine code has to be executed right this has to be executed by CPU right this machine code has to be executed this machine code is nothing but a sequence of instruction so what is thread a thread is the smallest sequence of instruction that are executed by the CPU independently there can be multiple threads so let's say these sequence of instructions are executed by this thread this sequence of instructions are executed by this thread this sequence of instructions are executed by this thread so that's what thread says that that a smallest sequence of instructions that are executed by CPU independently okay when a process is created it start with one thread and that initial thread known as main thread and from that we can create multiple thread to perform task concurrently now let's understand this so here if you see this is a very very basic Java class I have created a class given a class name multi- threading learning and I have put a method public static void main is string args and I I'm just printing out this thread. Curren thread. getet name so now when the first I did Java C multithread learning. Java it will convert to the bite code now after that I will do Java multi-threaded learning what it will do is it will execute it so what jvm will do is it will create a new process right because this bite code has to be converted to machine code right and that machine code need to be run by the CPU so it has they need a process it required a lot of memory also there are lot of resources required so it is just you can say that interface to us hey Java and the class name now you get the output but at at the back there are lot of things required to convert bite code to machine code and from machine code it has to be submitted to the CPU and CPU has to run it and then we will get the output right so all is taken care by the process so now when at when you are executing this class Java multi-thread learning what will happen is a process is created a process will have its own memory let's say Heap memory and one thread will automatically get created right and that thread is known as main so here if you see that I am printing system. print thread name thread do current thread get name what it printed mean so that's what it says that when a process is created it is start with one thread and that initial thread is known as main thread so automatically it will create one thread that is known as main thread and from that we can create multiple threads to perform task concurrently so let's say this is your program right you have this is your main thread main thread main thread is running now you can create thread one and which can perform certain tasks you can have thread two which can do per certain task and then after that again you have sequence of instruction which is again followed by main thread only right so whenever you execute a code a starting point it process will create one main thread and start executing the code and from this main thread you can initiate more threads right so one process can have multiple threads right process one thread one thread  thread three so first of all is process and thread is basic definition is clear we will now go level deeper But first you have to understand when does the process get created right and what is actually process is right so whenever we try to execute a program process is created process is nothing but you can say that it uh it takes care of like execution of the program the execution of the program required memory right they are converting bite code to machine code there are so many things happens and we have to submit to the CPU right so there's a process after this step go to this step this step to those step that is known as process right so whenever we ex try to execute a program a process is created and each process has multiple threads and thread is nothing but a smaller sequence of instructions that are executed okay so now if the basics is clear we will let's understand little bit more about process and threads right so here is the diagram uh there are so many things I'll try to go in depth of each so first understand that jvm like if you remember of initial video right where we have discussed about memory management and garbage collector I have told you that jvm has uh like one it has Heap it has has a stack memory also right so jvm has lot of memories so here if you go a little bit more depth jvm has Heap stack code segment data segment it will have registers it will have program counter and there are so others so these are all memory areas right Heap and stack is just one where you required garbage collector Concepts but apart from Heap and STC there are so many other memory also like code segment data segment register PC right so jvm has all of this now why I'm telling you all of this now so understand this right when we are executing a program Java let's say your main class um Java main right we know that it will execute your program and you will get the output but how how internally it works how it creates a process where it will execute the code that we have to understand so what is the first step so first step is it will create a process it will create a process second thing is a new jvm instance a new jvm instance is created so here if you see that the jvm has so many memories so whenever a process is created whenever a new process is created you can say that a new jvm instance a new jvm M instance is allocated to that process right because to execute a program you need certain memories right so jvm provide those right so whenever a new process is created a new jvm instance is created and allocated to that process and jvm instan has all this memory so that's you can see in this diagram so now let's say the process is created let's say this is the process which is getting created right this so for process two this is the process which is created now for each process a new jvm instance is created so here let's say a new jvm instance is created so this is process one so for it it say jvm instance one this is processor two for it it say jvm instance  different right and each jvm instance has all of this memories it will have Heap memory it will have code segment data segment register stack counter right now you can the questions might be coming into your mind Hey sh you have uh initially told that jvm has let's say Heap Heap size let's say its Heap size is  GP assume that right this Heap is gb now whenever a new process is created a new instance is given a new jvm instance is given to a process right and with that a heap memory is also allocated to that process so how much Heap memory is allocated to it is this process is allowed to use the complete heap of gb how much they can use a heap right this jvm instance is allowed how how much Heap so we can Define so whenever we create a process so when does the create process is created when we do Java this so here we can do this thing so this is generally how we run Java and your main your class name right so generally here if you see that we haven't defined like how much Heap memory they can use but we can tell that like this so hyphen X Ms which is for minimum and the size so this will set the initial Heap size so I let's say I allocated  MB so you can do that like this hyph x Ms m and if you want to allate the maximum Heap size you can do hyphen X MX size hyphen X MX I say G which is for GB right so whatever the process will get created a new jvm instance will be allocated and this jvm instance will use this to operation and allocate a minimum Heap size is  MB and maximum it can allot is GB only if required and if process is required to allocate more memory right out of memory error will come even though the jvm Heap has let's say  GB overall this has  GB overall but whenever a particular jvm instance is created we will allocate that whatever we have tell at the time of process uh execution program execution that hey MX let's say only one G G so only  GB for this another process I can say that okay  GB right but whatever the Heap memory is been used it is used out of this gb only like so no matter how many jvm instance you can create let's say if there are  process  jbm instance right and if they're using Heap memory so this Heap memory is allocated out of this gb only that whatever the total jvm Heap memory is allocated to the jvm so first thing is clear it create a process and with each process a new jvm instance is created right a jvm instance has all this memory space Heap memory stack code segment data segment register PC like this and how they are divided so now let's say that we have three threads I told you right in a process we have multiple threads so now let's say we have three threads thread one thread  thread three so now register stack and counter they are locally to each thread they do not threads do not share that to each other right they do not share to each other so this three thread what they do share they do share this code segment so here the code segment is shared among all the three threads data segment is shared among all the three threads Heap memory is shared among all these three threads but register register stack and counter they are local to each thread then what let's now first understand what is the use then we will try to see how this all comes into the picture right so now let's see first understand what is code segment so code segment contains the compile by code machine code of the Java program so you have this let's say main. Java file you have this main do Java file what is the first step you do you have done compilation Java C main. Java what it will generate bite code now when you want to execute it what you will do Java main so now what will happen is it will create a process it will create a jvm instance right and also one more thing will happen is it will initiate right jvm now you can say that the when the jvm is trans is created now jvm what it will do is it will interpret it interpret it or use the jit compiler to convert this bite code to machine code machine code is generated right so when you run Java this when you execute this program first process will get created second jvm instance will be allocated to that process this jvm instance use its interpreter or git compiler to convert this bite code to machine code so this code segment actually stores the compiled bite code or you can say that the machine code which CPU understand which our CPU understand this machine code so that is stored here code segment memory what is data segment data segment stores the global and static variable so inside your code if you have Global variable or static variable so the these are shared among all the threads so all those global data and static data are stored among data segments okay then we have a heap Heap is so here uh one thing I have forgot to tell you in the code segment it is read only because once you get the machine code you can't change it no threat can change it they can can just read that machine code data segment is they have Global and static variable threats can read and modify the same data so we need a proper synchronization between threats because threats can change the data which is present into Data segment so proper synchronization is required then Heap so this when these threats are getting executed they will definitely create new objects if required so when whenever they use a new keyword new objects are allocated a space into the Heap they are allocated a space into this Heap Heap is shared among all the threads of the same process but not within process so what I mean is this three threads have this access to this Heap memory but this process do not share this Heap memory so all the address which this Heap is pointing to is totally different from this Heap right so ultimately they they will go into the different address into the main memory like main different Heap right jvm has the main Heap memory so ultimately will they they all get mapped to a different location so they are totally different Heap memories process one process to do not share the memory locations but this thread  thread  thread three inside the particular process is sharing this Heap memory so Heap is Right thread can read and modify the Heap data synchronization is required between multiple threads for the Heap whatever the data is present into the Heap the threads can change it also okay so now you have cleared what does code segment is stored what does data segment is stor what does heap is stored right and Heap size can be differred between process to process now let's understand register stack and counter stack you know right each thread has its own stack it manage method called local variable in the first memory management garbage collector I explained a stack how stack is maintained they maintain local variables and all so each thread has their own stack then we have register so now what is the use of register so you see that CPU also have register the they also jvm also has a register so this register is used to store some intermediate values right so jvm like whenever you execute so whenever we convert bite code into machine code right sometime we have to like reshuffle the instructions right and there are certain immediate values so all those are stored into the register itself right so this register is used right whenever the jit uses it like whenever it compile convert the bite code into machine code right it uses register to optimize the machine code generated machine code because machine code uh instructions can be reshuffled some intermediate code has to be stored right so that is stored inside this register only and it also helps in contact switching I will tell you how very very important each thread its own register so each thread its own stack each thread its own register and let's understand what is counter so there is something called counter which is also known as PC which is program counter it points to the instruction which is getting executed increment its counter after successful execution of the instruction yeah this is very very confusing part right points to the instruction which is getting executed so I told you that code segment has the machine code right which has to be executed each threads are running you can say that some part of the code what part of the code they have to run the counter points the address of that instruction in the code segment okay you have to run this part you have to run this part you have to run this part of the code segment right don't worry now let's see how this is totally done and where this the this is the physical CPU comes into the picture but at least you got the concept right code segment data segment your stack register and counter counter like machine code machine code native machine code is present into code segment which CPU understand counter just holds that this thread need to run this instruction This Thread need to run this instruction so all this counter point the address to this code segment instruction which which code This Thread has to run but how now let's understand one complete flow okay first I have written one Java code let's say main do Java right and what will happen is I have certain code and then we have some piece of code which is executed by thread one let's say this is main thread and from this I created thread one which is doing this part of code then we have thread two which is doing this part of the code and then again after that this let's say I have written some code like this right so I have started executing of the code then I've created two threads which is doing certain a specific task and after that main main thread is again resuming it okay now what I have to do is first Java C main. Java now what will happen is the bite code will get generated bite codee will get generated now second I'm executing it Java main now when I'm executing it what would happen is process will be created one process will be created this this process will be created now once the process is created what it will do is jvm instance is allocated jvm instance is allocated right so it also allocated this jvm instance to a process right and jvm instance will have Heap memory let's say defined by here we have defined our xmx lesser  g  GB I have allocated this one right so I have initiated the jvm instance and this has code segment data segment right so currently it doesn't uh have the threats right now so now what it will do is this jvm will start doing interpreting or git compiling just in time compiler will start converting the bite code to machine code and while it is converting this bite code to machine code it knows that hey I have thread one thread two the three threads are required main thread thread one thread two so what it will do is it will create three threads right and for each thread it will assign a stack register and counter so for each thread stack register and counter is will be assigned by the jvm schedu okay so it created three threads after while converting it to this uh machine code right it get to know that okay I need three threads for this uh executing this main thread then thread thread one thread two right and it will assign this machine code like from this machine code it will create this three threads and three threads will have this register stack counter right now whatever this machine code is generated right it will save this machine code into code segment so this now code segment has the machine code which is generated so this will have the machine code which CPU understand this will have the complete machine code of this okay now this counter will point to an address into this machine code let's say this is thread is for this one is main thread This Thread two is let's say for T and this thread is T okay so this let's say T is exec executing this right so it its counter program counter is pointing to an address where in this machine code this getting started right similarly the thread two let's say these are the code uh thread  has to execute this program counter has the address on the machine code the code segment memory where the threat to has to start executing you got so they have the the counter program counter has the address of the code segment where this threads have to start working okay so this is also done now we have to start execution of this we have to start execution of this program right so who will run the program jvm doesn't run the program right right CPU has to execute this machine codee so what we'll do is this thread right so what happen is that this thread this register it uses this register so it is very similar to CPU register right so what will happen is let's say understand that you have only one CPU you have only one CPU it has only one register right it has its cache and RAM let's say that you have only one CPU One Core nothing there is nothing like a two core it's only one CPU right now we have three threads now what will happen is the three thread has to now they have the machine code now they have to run so what will do is let's say main thread is start running it so what main threat will do is that it uses the register right it will store the data and it will assign it to the CPU right so CPU what it will do is it will start executing this main thread so who takes care of assigning this to CPU so the OS schedule or you can say that manage this threads there are like sometime OS and there we also have jvm schedulers also so OS itself manage jvm scheduler so that's why we say that OS schedules this threats which need to be executed right so all these threats which has the program counter like it is pointing to machine code now they are just waiting to get executed now OS will schedule it that and what they will do is they will assign it to the CPU right hey CPU run their code now now what CPU will do is that from this program counter like it will load this machine code into the memory so here in the register it can load and it will provide to the CPU CPU will now start executing it machine code right and CPU can use this register to store the intermediate results and all so it can uh start executing this right now let's say that each thread OS has given a time of let's say Okay  second you can run after that you have to wait some other has somebody else has to run because there's only one CPU now let's say main thread was running right so it from this program counter it loads the machine in instruction machine code has a sequence of instruction so it load the instruction which This Thread has to execute right into the register you can say that it's a kind of a virtual memory register now OS will assign it to the CPU hey you executed now that instruction is read by the CPU and it will start executing it it will use its register to store the intermediate result and all but while it is processing it let's say  second is completed now what it will do is it will have to do context switching context switching very important so contact switching means now what it will do is all the results which CPU has generated let's say till % CPU has completed so whatever the % data CPU has completed in this register it will get stored and Os will now use run another threat hey now he main thread whatever the CPU has run you store in your register and you wait now I'm running thread one so now let's say thread one is running so now thread one is running let's say after  second thread one also time completed let's say thread one completed % so what it will do is all the intermediate data from the register and whatever the CPU has completed it will put into its thread one register and it will do a contact switch and it will now start thread two right so like this so when let's say thread one or main thread turn comes again let's say thread one turn come again so what it will do is it will use its register load it back again and start from that itself so thread one was completed let's say % right so all that % data is present into register so when it's turn again come it will put into the register back CPU and CPU start from where it left right so that is known as contact switching right so this is the term this is the scenario when there we have only one CPU now let's say we have multiple CPU let's say we have multiple CPU so when we have multiple CPU it is that CPU this CPU one is running thread one this CPU is running thread two so they are actually running parallell when we have multiple CPU codes it is possible that two threads can run actual parallel if if CPU cores are two and there are let's say  threads thread  thread  thread three thread  thread  so definitely we have to do context switching right it first run this then it run this like so each will do context switching right so contact switching means they are not actually running parallell but it looks like they are run parall like all are running simultaneously it looks like but internally CPU is doing contact switching right but let's say if you have two CPU core or let's say four core four CPU core CPU  CPU  CPU  CPU  and let's say you have three threads thread  thread  thread three all thread one thread  thread three can run actual parall they are actually running parall no cont Swit is required in that case so you got it so this machine code how this code segment and this program counter are related right you got right so each one is pointing program counter is like where this thread has to start executing and it will keep on incrementing as soon as this instr instruction is successfully completed by the CPU okay so program counter will keep on increasing the its uh counter like whatever the code This Thread has to execute whatever the code This Thread has to execute this counter keep on executing uh counting it the address it will point to the address where the next instruction has to be loaded from this machine code so here if you see that the code segment is same all this three threads are just using this counter address from this code segment which has the machine code and it just tell the CPU that he read this instruction and execute it so that's why they are actually doing things parallely right sometime if CPU is less there are more thre parall in the terms is contact switching it looks like they are working parallely but actually it's not but sometime when the CPU CES are more than thread is less it actually runs parallel so this is clear totally how the process threads are actually run right so code segment data segment Heap stack register counter should be super clear right I told you right register helps in contact switching how you got it right because uh let's say if time time time up happen for the particular thread OS will take all the intermediate data from the CPU and put it into its register and it has to wait next time when it will have to come back it will use its register put it back to the CPU and start from there itself now you have know about process and threats now let's understand definition of multi-threading so now can you explain it multi-threading is allow a program to perform multiple task at the same time right multiple operation at the same time you can do right instead of task I would say that multiple operations at the same time itself multiple threads share the same resource such as memory space but still can perform task independently right you got it right they do share a common resource like code segment they do share this data segment this is the memory they share Heap memory they also share this right but they also have some independent memory which helps them to run individually what are the benefits and challenge of multi-threading benefit is improve performance by task parallelism so definitely by the task so let's say if you have two CPU right so if you have thread one and thread one has to perform all all the instruction sequentially so only one CPU will do so with parallelism you can do two threads thread one thread two you can divide the task some of the task to it and they can perform parall right so it perform the performance by task parallelism responsiveness definitely it brings the response faster to the clients right performance is performance improve definitely the output result or responsiveness of the application will get improved also so resource sharing this multi-threading they are utilizing the resource very well so here if you see they are doing resource sharing so they are utilizing the resource very well right so resource sharing also you can say that uh it's a benefit like it's uh not that much expensive because they do share the resource so resource sharing is also a benefit that yes multi- threading allow you to share the resource between multiple threads but there are few challenges first challenge is that concurrency issue like since they are accessing the same resource like Heap memory uh I told you data segment there are Global variables and all it is possible that deadlock data inconsistency can happen so we have to handle that and how to handle that through synchronization and that is an extra overhead we have to put lock synchronized block that is an extra overhead and sometime multi-threading make code difficult and testing and debugging is difficult right so I'm not sure in live have you fa this not I have faced this because of this concurrency sometime it's very get difficult to debug it because there is no test case return as it is difficult to test in local itself so these are the few challenges which I thought and before last there is sometime confusion happen or interview as what difference between multi asking Al is multi-threading so here the answer lies here itself so process one process two is multitasking this is Task one this is Task two right so this is known as multitasking and inside a particular task we can create multiple threads that is known as multi-threading in the multi- threading there share the resources in the multitasking they do not share the resources at all right so here if you see that in the thread they these three threads share this Heap memory share this code segment share this data segment but this task multitask they never share any resource code segment is also different Heap memory is also different all the resource are different right that's the only difference so different process is known as you can say that different tasks right and inside a particular process we have multiple threads and when they are executing that's called multi-threading and when the program execute multiple process like by Contex switching that is known as multitasking okay multitasking they do not share any resource but inside the multi-threading threats do share the resource okay guys so I think it should be clear this totally should be understand properly like how context switch happen how this jvm help the processes right uh so all this things should be clear and yeah next we'll see the how to create a threads in Java okay guys thank you bye 
