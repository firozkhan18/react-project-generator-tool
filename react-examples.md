Here's a **Table of Contents** with clear navigation for the ReactJS Series, React Hooks Series, React Render Series, and React with TypeScript Series.

---

### **ReactJS Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 1     | ReactJS - Introduction                                                  | [ReactJS - Introduction](#1-reactjs---introduction)            |
| 2     | ReactJS - Hello World                                                   | [ReactJS - Hello World](#2-reactjs---hello-world)                        |
| 3     | ReactJS - Folder Structure                                              | [ReactJS - Folder Structure](#3-reactjs---folder-structure)              |
| 4     | ReactJS - Components                                                    | [ReactJS - Components](#4-reactjs---components)                          |
| 5     | ReactJS - Functional Components                                         | [ReactJS - Functional Components](#5-reactjs---functional-components)    |
| 6     | ReactJS - Class Components                                              | [ReactJS - Class Components](#6-reactjs---class-components)              |
| 7     | ReactJS - Hooks Update                                                  | [ReactJS - Hooks Update](#7-reactjs---hooks-update)                      |
| 8     | ReactJS - JSX                                                          | [ReactJS - JSX](#8-reactjs---jsx)                                        |
| 9     | ReactJS - Props                                                         | [ReactJS - Props](#9-reactjs---props)                                    |
| 10    | ReactJS - State                                                         | [ReactJS - State](#10-reactjs---state)                                    |
| 11    | ReactJS - setState                                                      | [ReactJS - setState](#11-reactjs---setstate)                              |
| 12    | ReactJS - Destructuring props and state                                  | [ReactJS - Destructuring props and state](#12-reactjs---destructuring-props-and-state) |
| 13    | ReactJS - Event Handling                                                | [ReactJS - Event Handling](#13-reactjs---event-handling)                  |
| 14    | ReactJS - Binding Event Handlers                                        | [ReactJS - Binding Event Handlers](#14-reactjs---binding-event-handlers)  |
| 15    | ReactJS - Methods as props                                              | [ReactJS - Methods as props](#15-reactjs---methods-as-props)               |
| 16    | ReactJS - Conditional Rendering                                         | [ReactJS - Conditional Rendering](#16-reactjs---conditional-rendering)    |
| 17    | ReactJS - List Rendering                                                | [ReactJS - List Rendering](#17-reactjs---list-rendering)                  |
| 18    | ReactJS - Lists and Keys                                                | [ReactJS - Lists and Keys](#18-reactjs---lists-and-keys)                  |
| 19    | ReactJS - Index as Key Anti-pattern                                     | [ReactJS - Index as Key Anti-pattern](#19-reactjs---index-as-key-anti-pattern) |
| 20    | ReactJS - Styling and CSS Basics                                        | [ReactJS - Styling and CSS Basics](#20-reactjs---styling-and-css-basics)  |
| 21    | ReactJS - Basics of Form Handling                                       | [ReactJS - Basics of Form Handling](#21-reactjs---basics-of-form-handling) |
| 22    | ReactJS - Component Lifecycle Methods                                   | [ReactJS - Component Lifecycle Methods](#22-reactjs---component-lifecycle-methods) |
| 23    | ReactJS - Component Mounting Lifecycle Methods                         | [ReactJS - Component Mounting Lifecycle Methods](#23-reactjs---component-mounting-lifecycle-methods) |
| 24    | ReactJS - Component Updating Lifecycle Methods                         | [ReactJS - Component Updating Lifecycle Methods](#24-reactjs---component-updating-lifecycle-methods) |
| 25    | ReactJS - Fragments                                                     | [ReactJS - Fragments](#25-reactjs---fragments)                            |
| 26    | ReactJS - Pure Components                                               | [ReactJS - Pure Components](#26-reactjs---pure-components)                |
| 27    | ReactJS - memo                                                          | [ReactJS - memo](#27-reactjs---memo)                                      |
| 28    | ReactJS - Refs                                                           | [ReactJS - Refs](#28-reactjs---refs)                                       |
| 29    | ReactJS - Refs with Class Components                                    | [ReactJS - Refs with Class Components](#29-reactjs---refs-with-class-components) |
| 30    | ReactJS - Forwarding Refs                                               | [ReactJS - Forwarding Refs](#30-reactjs---forwarding-refs)                |
| 31    | ReactJS - Portals                                                       | [ReactJS - Portals](#31-reactjs---portals)                                |
| 32    | ReactJS - Error Boundary                                                | [ReactJS - Error Boundary](#32-reactjs---error-boundary)                  |
| 33    | ReactJS - Higher Order Components (Part 1)                              | [ReactJS - Higher Order Components (Part 1)](#33-reactjs---higher-order-components-part-1) |
| 34    | ReactJS - Higher Order Components (Part 2)                              | [ReactJS - Higher Order Components (Part 2)](#34-reactjs---higher-order-components-part-2) |
| 35    | ReactJS - Higher Order Components (Part 3)                              | [ReactJS - Higher Order Components (Part 3)](#35-reactjs---higher-order-components-part-3) |
| 36    | ReactJS - Render Props (Part 1)                                         | [ReactJS - Render Props (Part 1)](#36-reactjs---render-props-part-1)       |
| 37    | ReactJS - Render Props (Part 2)                                         | [ReactJS - Render Props (Part 2)](#37-reactjs---render-props-part-2)       |
| 38    | ReactJS - Context (Part 1)                                              | [ReactJS - Context (Part 1)](#38-reactjs---context-part-1)                |
| 39    | ReactJS - Context (Part 2)                                              | [ReactJS - Context (Part 2)](#39-reactjs---context-part-2)                |
| 40    | ReactJS - Context (Part 3)                                              | [ReactJS - Context (Part 3)](#40-reactjs---context-part-3)                |
| 41    | ReactJS - HTTP and React                                                | [ReactJS - HTTP and React](#41-reactjs---http-and-react)                  |
| 42    | ReactJS - HTTP GET Request                                              | [ReactJS - HTTP GET Request](#42-reactjs---http-get-request)              |
| 43    | ReactJS - HTTP Post Request                                             | [ReactJS - HTTP Post Request](#43reactjs---http-post-request)            |

---

### **React Hooks Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 44    | React Hooks - Introduction                                               | [React Hooks - Introduction](#44-react-hooks---introduction)             |
| 45    | React Hooks - useState Hook                                              | [React Hooks - useState Hook](#45-react-hooks---usestate-hook)            |
| 46    | React Hooks - useState with previous state                              | [React Hooks - useState with previous state](#46-react-hooks---usestate-with-previous-state) |
| 47    | React Hooks - useState with object                                       | [React Hooks - useState with object](#47-react-hooks---usestate-with-object) |
| 48    | React Hooks - useState with array                                        | [React Hooks - useState with array](#48-react-hooks---usestate-with-array) |
| 49    | React Hooks - useEffect Hook                                             | [React Hooks - useEffect Hook](#49-react-hooks---useeffect-hook)          |
| 50    | React Hooks - useEffect after render                                    | [React Hooks - useEffect after render](#50-react-hooks---useeffect-after-render) |
| 51    | React Hooks - Conditionally run effects                                 | [React Hooks - Conditionally run effects](#501react-hooks---conditionally-run-effects) |
| 52    | React Hooks - Run effects only once                                     | [React Hooks - Run effects only once](#52-react-hooks---run-effects-only-once) |
| 53    | React Hooks - useEffect with cleanup                                    | [React Hooks - useEffect with cleanup](#53-react-hooks---useeffect-with-cleanup) |
| 54    | React Hooks - useEffect with incorrect dependency                       | [React Hooks - useEffect with incorrect dependency](#54-react-hooks---useeffect-with-incorrect-dependency) |
| 55    | React Hooks - Fetching data with useEffect Part 1                       | [React Hooks - Fetching data with useEffect Part 1](#55-react-hooks---fetching-data-with-useeffect-part-1) |
| 56    | React Hooks - Fetching data with useEffect Part 2                       | [React Hooks - Fetching data with useEffect Part 2](#56-react-hooks---fetching-data-with-useeffect-part-2) |
| 57    | React Hooks - Fetching data with useEffect Part 3                       | [React Hooks - Fetching data with useEffect Part 3](#57-react-hooks---fetching-data-with-useeffect-part-3) |
| 58    | React Hooks - useContext Hook Part 1                                     | [React Hooks - useContext Hook Part 1](#58-react-hooks---usecontext-hook-part-1) |
| 59    | React Hooks - useContext Hook Part 2                                     | [React Hooks - useContext Hook Part 2](#59-react-hooks---usecontext-hook-part-2) |
| 60    | React Hooks - useContext Hook Part 3                                     | [React Hooks - useContext Hook Part 3](#60-react-hooks---usecontext-hook-part-3) |
| 61    | React Hooks - useReducer Hook                                           | [React Hooks - useReducer Hook](#61-react-hooks---usereducer-hook)       |
| 62    | React Hooks - useReducer (simple state & action)                        | [React Hooks - useReducer (simple state & action)](#62-react-hooks---usereducer-simple-state-action) |
| 63    | React Hooks - useReducer (complex state & action)                       | [React Hooks - useReducer (complex state & action)](#63-react-hooks---usereducer-complex-state-action) |
| 64    | React Hooks - Multiple useReducers                                      | [React Hooks - Multiple useReducers](#64-react-hooks---multiple-usereducers) |
| 65    | React Hooks - useReducer with useContext                                | [React Hooks - useReducer with useContext](#65-react-hooks---usereducer-with-usecontext) |
| 66    | React Hooks - Fetching data with useReducer Part 1                       | [React Hooks - Fetching data with useReducer Part 1](#66-react-hooks---fetching-data-with-usereducer-part-1) |
| 67    | React Hooks - Fetching data with useReducer Part 2                       | [React Hooks - Fetching data with useReducer Part 2](#67-react-hooks---fetching-data-with-usereducer-part-2) |
| 68    | React Hooks - useState vs useReducer                                     | [React Hooks - useState vs useReducer](#68-react-hooks---usestate-vs-usereducer) |
| 69    | React Hooks - useCallback Hook                                           | [React Hooks - useCallback Hook](#69-react-hooks---usecallback-hook)     |
| 70    | React Hooks - useMemo Hook                                              | [React Hooks - useMemo Hook](#70-react-hooks---usememo-hook)             |
| 71    | React Hooks - useRef Hook Part 1                                         | [React Hooks - useRef Hook Part 1](#71-react-hooks---useref-hook-part-1) |
| 72    | React Hooks - useRef Hook Part 2                                         | [React Hooks - useRef Hook Part 2](#72-react-hooks---useref-hook-part-2) |
| 73    | React Hooks - Custom Hooks                                              | [React Hooks - Custom Hooks](#73-react-hooks---custom-hooks)            |
| 74    | React Hooks - useDocumentTitle Custom Hook                              | [React Hooks - useDocumentTitle Custom Hook](#74-react-hooks---usedocumenttitle-custom-hook) |
| 75    | React Hooks - useCounter Custom Hook                                    | [React Hooks - useCounter Custom Hook](#75-react-hooks---usecounter-custom-hook) |
| 76    | React Hooks - useInput Custom Hook                                      | [React Hooks - useInput Custom Hook](#76-react-hooks---useinput-custom-hook) |

---

### **React Render Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 77    | React Render - Introduction                                              | [React Render - Introduction](#77-react-render---introduction)          |
| 78    | React Render - Rendering                                                 | [React Render - Rendering](#78-react-render---rendering)                |
| 79    | React Render - useState                                                 | [React Render - useState](#79-react-render---usestate)                   |
| 80    | React Render - useReducer                                               | [React Render - useReducer](#80-react-render---usereducer)               |
| 81    | React Render - State Immutability                                       | [React Render - State Immutability](#81-react-render---state-immutability) |
| 82    | React Render - Parent and Child                                         | [React Render - Parent and Child](#82-react-render---parent-and-child)  |
| 83    | React Render - Same Element Reference                                   | [React Render - Same Element Reference](#83-react-render---same-element-reference) |
| 84    | React Render - React memo                                               | [React Render - React memo](#84-react-render---react-memo)               |
| 85    | React Render - Questions on Optimization                                | [React Render - Questions on Optimization](#85-react-render---questions-on-optimization) |
| 86    | React Render - Incorrect memo with children                             | [React Render - Incorrect memo with children](#86-react-render---incorrect-memo-with-children) |
| 87    | React Render - Incorrect memo with Impure Component                     | [React Render - Incorrect memo with Impure Component](#87-react-render---incorrect-memo-with-impure-component) |
| 88    | React Render - Incorrect memo with props Reference                      | [React Render - Incorrect memo with props Reference](#88-react-render---incorrect-memo-with-props-reference) |
| 89    | React Render - useMemo and useCallback                                  | [React Render - useMemo and useCallback](#89-react-render---usememo-and-usecallback) |
| 90    | React Render - Context                                                  | [React Render - Context](#90-react-render---context)                     |
| 91    | React Render - Context and memo                                         | [React Render - Context and memo](#91-react-render---context-and-memo)  |
| 92    | React Render - Context and Same Element Reference                       | [React Render - Context and Same Element Reference](#92-react-render---context-and-same-element-reference) |

---

### **React with TypeScript Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 93    | React TypeScript - Introduction                                          | [React TypeScript - Introduction](#93-react-typescript---introduction)   |
| 94    | React TypeScript - Getting Started                                      | [React TypeScript - Getting Started](#94-react-typescript---getting-started) |
| 95    | React TypeScript - Typing Props                                         | [React TypeScript - Typing Props](#95-react-typescript---typing-props)    |
| 96    | React TypeScript - Basic Props                                          | [React TypeScript - Basic Props](#96-react-typescript---basic-props)      |
| 97    | React TypeScript - Advanced Props                                       | [React TypeScript - Advanced Props](#97-react-typescript---advanced-props) |
| 98    | React TypeScript - Event Props                                          | [React TypeScript - Event Props](#98-react-typescript---event-props)      |
| 99    | React TypeScript - Style Props                                          | [React TypeScript - Style Props](#99-react-typescript---style-props)      |
| 100   | React TypeScript - Prop Types and Tips                                  | [React TypeScript - Prop Types and Tips](#100-react-typescript---prop-types-and-tips) |
| 101   | React TypeScript - useState Hook                                        | [React TypeScript - useState Hook](#101-react-typescript---usestate-hook) |
| 102   | React TypeScript - useState Future Value                                | [React TypeScript - useState Future Value](#102-react-typescript---usestate-future-value) |
| 103   | React TypeScript - useState Type Assertion                              | [React TypeScript - useState Type Assertion](#103-react-typescript---usestate-type-assertion) |
| 104   | React TypeScript - useReducer Hook                                      | [React TypeScript - useReducer Hook](#104-react-typescript---usereducer-hook) |
| 105   | React TypeScript - useReducer Strict Action Types                       | [React TypeScript - useReducer Strict Action Types](#105-react-typescript---usereducer-strict-action-types) |
| 106   | React TypeScript - useContext Hook                                      | [React TypeScript - useContext Hook](#106-react-typescript---usecontext-hook) |
| 107   | React TypeScript - useContext Future Value                              | [React TypeScript - useContext Future Value](#107-react-typescript---usecontext-future-value) |
| 108   | React TypeScript - useRef Hook                                          | [React TypeScript - useRef Hook](#108-react-typescript---useref-hook)     |
| 109   | React TypeScript - Class Component                                      | [React TypeScript - Class Component](#109-react-typescript---class-component) |
| 110   | React TypeScript - Component Prop                                       | [React TypeScript - Component Prop](#110-react-typescript---component-prop) |
| 111   | React TypeScript - Generic Props                                        | [React TypeScript - Generic Props](#111-react-typescript---generic-props)  |
| 112   | React TypeScript - Restricting Props                                    | [React TypeScript - Restricting Props](#112-react-typescript---restricting-props) |
| 113   | React TypeScript - Template Literals and Exclude                        | [React TypeScript - Template Literals and Exclude](#113-react-typescript---template-literals-and-exclude) |
| 114   | React TypeScript - Wrapping HTML Elements                               | [React TypeScript - Wrapping HTML Elements](#114-react-typescript---wrapping-html-elements) |
| 115   | React TypeScript - Extracting a Components Prop Types                   | [React TypeScript - Extracting a Components Prop Types](#115-react-typescript---extracting-a-components-prop-types) |
| 116   | React TypeScript - Polymorphic Components                               | [React TypeScript - Polymorphic Components](#116-react-typescript---polymorphic-components) |
| 117   | React TypeScript - Wrapping up                                          | [React TypeScript - Wrapping up](#117-react-typescript---wrapping-up)      |

---

### 1. ReactJS - Introduction

- **Concepts Covered**:
 - Introduction to React
 - Why use React?
 - Core features of React (Declarative, Component-based, Learn once, write anywhere, etc.)

- **Example**:
  React is a declarative, efficient, and flexible JavaScript library for building user interfaces. It lets you build complex UIs from small and isolated pieces of code called “components.”

```jsx
// Simple React component
import React from 'react';

const App = () => {
  return (
    <div>
      <h1>Hello, World! Welcome to React!</h1>
    </div>
  );
};

export default App;
```

---

### 2. ReactJS - Hello World

- **Concepts Covered**:
 - How to set up a simple React app
 - Running React in the browser using `create-react-app`

- **Example**:
  Here’s a simple "Hello World" app. You can use `create-react-app` to quickly start a React app.

```bash
npx create-react-app hello-world
cd hello-world
npm start
```

In `src/App.js`:

```jsx
import React from 'react';

function App() {
  return (
    <div className="App">
      <h1>Hello, World!</h1>
    </div>
  );
}

export default App;
```

---

### 3. ReactJS - Folder Structure

- **Concepts Covered**:
 - Typical folder structure in a React project.
 - How to organize components, assets, and config files.

- **Example**:
  Here’s an ideal folder structure for a React project:

```
/src
  /components
    Header.js
    Footer.js
  /assets
    logo.png
  /styles
    App.css
  App.js
  index.js
```

```jsx
// Example in App.js
import React from 'react';
import './styles/App.css';  // Importing styles

function App() {
  return <div className="App">Hello, World!</div>;
}

export default App;
```

---

### 4. ReactJS - Components

- **Concepts Covered**:
 - Functional vs. Class components in React.
 - Creating reusable components.

- **Example**:
  **Functional Component:**

```jsx
// Functional Component
const Greeting = () => {
  return <h1>Hello, Welcome to React!</h1>;
};
```

**Class Component:**

```jsx
// Class Component
import React, { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, Welcome to React!</h1>;
  }
}

export default Greeting;
```

---

### 5. ReactJS - Functional Components

- **Concepts Covered**:
 - Writing functional components using JSX syntax.

- **Example**:
  Here’s a stateless functional component that displays a greeting:

```jsx
const Greeting = (props) => {
  return <h1>{props.message}</h1>;
};

export default Greeting;
```

You can use it in the main `App` component:

```jsx
import React from 'react';
import Greeting from './Greeting';

const App = () => {
  return (
    <div>
      <Greeting message="Hello, React!" />
    </div>
  );
};

export default App;
```

---

### 6. ReactJS - Class Components

- **Concepts Covered**:
 - Creating class-based components.
 - Lifecycle methods in class components.

- **Example**:
  Class components come with lifecycle methods such as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = {
      count: 0,
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

---

### 7. ReactJS - Hooks Update

- **Concepts Covered**:
 - Introduction to React Hooks.
 - Using `useState` and `useEffect`.

- **Example**:
  Using the `useState` hook for managing state in a functional component:

```jsx
import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default Counter;
```

---

### 8. ReactJS - JSX

- **Concepts Covered**:
 - Understanding JSX and how it’s compiled to React’s `createElement`.

- **Example**:
  JSX is a syntax extension for JavaScript that looks similar to HTML. It allows us to write elements and components in a declarative way.

```jsx
const element = <h1>Hello, World!</h1>;
```

Behind the scenes, JSX is converted to JavaScript code using `React.createElement()`:

```jsx
const element = React.createElement('h1', null, 'Hello, World!');
```

---

### 9. ReactJS - Props

- **Concepts Covered**:
 - Props in React components.
 - Passing data from parent to child components.

- **Example**:
  Here’s how you can pass props to a child component:

```jsx
const Greeting = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

const App = () => {
  return <Greeting name="John" />;
};
```

---

### 10. ReactJS - State

- **Concepts Covered**:
 - Introduction to state in React and how to manage it.

- **Example**:
  A controlled form component that updates state based on user input:

```jsx
import React, { useState } from 'react';

const Form = () => {
  const [input, setInput] = useState('');

  const handleChange = (e) => setInput(e.target.value);

  return (
    <form>
      <input type="text" value={input} onChange={handleChange} />
      <p>{input}</p>
    </form>
  );
};

export default Form;
```

---

### 11. ReactJS - setState

- **Concepts Covered**:
 - Using `setState` in class components to update the state.

- **Example**:
  Here’s how you use `setState` to update state in class components:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

---

### 12. ReactJS - Destructuring props and state

- **Concepts Covered**:
 - Destructuring props and state to improve code readability.

- **Example**:
  Here’s how destructuring works in functional components:

```jsx
const Greeting = ({ name, age }) => {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>You are {age} years old.</p>
    </div>
  );
};
```

In this example, `name` and `age` are destructured directly from `props`.

---

### 13. ReactJS - Event Handling

- **Concepts Covered**:
 - Handling events like `onClick`, `onSubmit` in React.

- **Example**:
  Handling a click event in React:

```jsx
import React, { useState } from 'react';

const ButtonClick = () => {
  const [clicked, setClicked] = useState(false);

  const handleClick = () => setClicked(true);

  return (
    <div>
      <button onClick={handleClick}>Click Me!</button>
      {clicked && <p>You clicked the button!</p>}
    </div>
  );
};

export default ButtonClick;
```

---


### 14. ReactJS - Binding Event Handlers

- **Concepts Covered**:
  - Binding event handlers in class components.
  - How to use `this` in event handler methods.

- **Example**:
  In class components, methods need to be explicitly bound to the component instance using `.bind()`. Here’s an example:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = { count: 0 };
    // Binding the method to the component instance
    this.increment = this.increment.bind(this);
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

Alternatively, binding can also be done using an arrow function:

```jsx
<button onClick={() => this.increment()}>Increment</button>
```

---

### 15. ReactJS - Methods as Props

- **Concepts Covered**:
  - Passing methods as props from parent to child components.

- **Example**:
  Here, we pass a method from the parent (`App`) to the child (`ChildComponent`):

```jsx
// Parent Component
const App = () => {
  const handleClick = () => {
    alert("Button clicked!");
  };

  return <ChildComponent onClick={handleClick} />;
};

// Child Component
const ChildComponent = ({ onClick }) => {
  return <button onClick={onClick}>Click Me</button>;
};

export default App;
```

---

### 16. ReactJS - Conditional Rendering

- **Concepts Covered**:
  - Conditionally rendering components using JavaScript expressions.

- **Example**:
  Rendering content based on a condition, such as user authentication:

```jsx
import React, { useState } from 'react';

const App = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  return (
    <div>
      {isAuthenticated ? (
        <h1>Welcome back, User!</h1>
      ) : (
        <button onClick={() => setIsAuthenticated(true)}>Login</button>
      )}
    </div>
  );
};

export default App;
```

---

### 17. ReactJS - 17 - List Rendering

- **Concepts Covered**:
  - Rendering lists in React using `.map()`.

- **Example**:
  Displaying a list of items dynamically:

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
};

export default List;
```

---

### 18. ReactJS - Lists and Keys

- **Concepts Covered**:
  - Using `key` prop when rendering lists to optimize performance and ensure proper re-rendering.

- **Example**:
  When rendering dynamic lists, `key` helps React identify which items have changed, been added, or removed:

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item) => (
        <li key={item}>{item}</li> // Using a unique value for 'key'
      ))}
    </ul>
  );
};

export default List;
```

---

### 19. ReactJS - Index as Key Anti-pattern

- **Concepts Covered**:
  - Why using the index as the key can be problematic, especially with dynamic lists.

- **Example**:
  **Bad Practice:**

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li> // Using index as key
      ))}
    </ul>
  );
};
```

Using `index` as a key might cause issues with reordering elements. A better approach is to use unique values as keys:

```jsx
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' },
];

const List = () => {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li> // Using unique 'id' as key
      ))}
    </ul>
  );
};
```

---

### 20. ReactJS - Styling and CSS Basics

- **Concepts Covered**:
  - Different ways to style React components (inline styles, external CSS, CSS modules).

- **Example**:
  - **Inline Styles**:

```jsx
const App = () => {
  const divStyle = {
    color: 'blue',
    backgroundColor: 'lightgray',
  };

  return <div style={divStyle}>Styled Div</div>;
};

export default App;
```

  - **External CSS**:

```jsx
// App.css
.App {
  color: blue;
  background-color: lightgray;
}

// App.js
import './App.css';

const App = () => {
  return <div className="App">Styled Div</div>;
};

export default App;
```

  - **CSS Modules**:

```jsx
// App.module.css
.container {
  color: blue;
  background-color: lightgray;
}

// App.js
import styles from './App.module.css';

const App = () => {
  return <div className={styles.container}>Styled Div</div>;
};

export default App;
```

---

### 21. ReactJS - Basics of Form Handling

- **Concepts Covered**:
  - Handling forms in React with controlled components.

- **Example**:
  A simple controlled form:

```jsx
import React, { useState } from 'react';

const Form = () => {
  const [input, setInput] = useState('');

  const handleChange = (e) => {
    setInput(e.target.value);
  };

  return (
    <form>
      <input type="text" value={input} onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
};

export default Form;
```

---

### 22. ReactJS - Component Lifecycle Methods

- **Concepts Covered**:
  - Lifecycle methods such as `componentDidMount` and `componentDidUpdate` in class components.

- **Example**:
  Using `componentDidMount()` to fetch data:

```jsx
import React, { Component } from 'react';

class DataFetcher extends Component {
  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
  }

  render() {
    return <div>{this.state ? this.state.data : 'Loading...'}</div>;
  }
}

export default DataFetcher;
```

---

### 23. ReactJS - Component Mounting Lifecycle Methods

- **Concepts Covered**:
  - Mounting phase lifecycle methods: `constructor()`, `render()`, `componentDidMount()`.

- **Example**:
  Using `componentDidMount` to fetch data after the initial render:

```jsx
class App extends React.Component {
  constructor() {
    super();
    this.state = { data: null };
  }

  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
  }

  render() {
    return <div>{this.state.data ? this.state.data : 'Loading...'}</div>;
  }
}

export default App;
```

---

### 24. ReactJS - Component Updating Lifecycle Methods

- **Concepts Covered**:
  - Lifecycle methods for handling updates: `shouldComponentUpdate`, `componentDidUpdate`.

- **Example**:
  Using `componentDidUpdate` to react to prop changes:

```jsx
import React, { Component } from 'react';

class App extends Component {
  componentDidUpdate(prevProps) {
    if (this.props.value !== prevProps.value) {
      console.log('Value updated:', this.props.value);
    }
  }

  render() {
    return <div>{this.props.value}</div>;
  }
}

export default App;
```

---

### 25. ReactJS - Fragments

- **Concepts Covered**:
  - Using `React.Fragment` to group elements without adding extra DOM nodes.

- **Example**:
  Wrapping multiple elements without introducing an additional parent node:

```jsx
const FragmentExample = () => (
  <React.Fragment>
    <h1>Title</h1>
    <p>Content</p>
  </React.Fragment>
);

export default FragmentExample;
```

---

### 26. ReactJS - Pure Components

- **Concepts Covered**:
 - Using `React.PureComponent` to optimize performance by preventing unnecessary re-renders.
 - `PureComponent` performs a shallow comparison of props and state to determine whether the component needs to re-render.

- **Example**:
  If a component's state or props haven't changed, it won't re-render, improving performance.

```jsx
import React, { PureComponent } from 'react';

class Counter extends PureComponent {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    console.log('Rendered');
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```
`PureComponent` ensures the component only re-renders when `props` or `state` change.

---

### 27. ReactJS - memo

- **Concepts Covered**:
 - `React.memo` for functional component optimization by memoizing the component and preventing unnecessary re-renders when props haven't changed.

- **Example**:
  Wrapping a functional component with `React.memo()` to optimize rendering:

```jsx
const Counter = React.memo(({ count, increment }) => {
  console.log('Rendered');
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
});

export default Counter;
```

`React.memo` is similar to `PureComponent` but for functional components.

---

### 28. ReactJS - Refs

- **Concepts Covered**:
 - Using `refs` to interact directly with DOM elements or React components.
 - `refs` are useful for tasks like focusing an input field, measuring elements, or triggering animations.

- **Example**:
  Focusing an input field using a ref:

```jsx
import React, { useRef } from 'react';

const FocusInput = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default FocusInput;
```

Here, `useRef` is used to create a reference to the input element, which we can then focus using `inputRef.current.focus()`.

---

### ReactJS - Refs with Class Components

- **Concepts Covered**:
 - Handling `refs` in class components.

- **Example**:
  Using `refs` in a class component to access a DOM element:

```jsx
import React, { Component } from 'react';

class FocusInput extends Component {
  constructor() {
    super();
    this.inputRef = React.createRef();
  }

  handleFocus = () => {
    this.inputRef.current.focus();
  };

  render() {
    return (
      <div>
        <input ref={this.inputRef} type="text" />
        <button onClick={this.handleFocus}>Focus Input</button>
      </div>
    );
  }
}

export default FocusInput;
```

In class components, `React.createRef()` is used to create refs, which are then accessed via `this.inputRef.current`.

---

### 30. ReactJS - Forwarding Refs

- **Concepts Covered**:
 - Forwarding refs to child components using `React.forwardRef()`.
 - This is useful when you need to pass refs through higher-order components or functional components.

- **Example**:
  Forwarding refs to a child component:

```jsx
import React, { forwardRef } from 'react';

const Input = forwardRef((props, ref) => (
  <input ref={ref} {...props} />
));

const Parent = () => {
  const inputRef = React.useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <Input ref={inputRef} />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Parent;
```

Here, `React.forwardRef` allows the `Input` component to accept a `ref` passed from the parent component.

---

### 31. ReactJS - Portals

- **Concepts Covered**:
 - Using `ReactDOM.createPortal` to render a component outside its parent DOM hierarchy, useful for modals, tooltips, etc.

- **Example**:
  Creating a modal component with portals:

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Modal = ({ children }) => {
  return ReactDOM.createPortal(
    <div className="modal">
      <div className="modal-content">{children}</div>
    </div>,
    document.getElementById('modal-root') // Rendering outside parent DOM
  );
};

export default Modal;
```

Here, the modal is rendered outside the main React component tree, allowing it to overlay on top of other content.

---

### 32. ReactJS - Error Boundary

- **Concepts Covered**:
 - Using Error Boundaries to catch JavaScript errors in components and display a fallback UI.

- **Example**:
  Implementing an Error Boundary to handle errors gracefully:

```jsx
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error occurred:", error);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

const BuggyComponent = () => {
  throw new Error('Oops!');
};

const App = () => (
  <ErrorBoundary>
    <BuggyComponent />
  </ErrorBoundary>
);

export default App;
```

`componentDidCatch` catches the error, while `getDerivedStateFromError` updates the UI to show a fallback message.

---

### 33. ReactJS - Higher Order Components (Part 1)

- **Concepts Covered**:
 - Introduction to Higher-Order Components (HOCs), which are functions that take a component and return a new component with enhanced functionality.

- **Example**:
  Creating a `withLoader` HOC that adds loading functionality to a component:

```jsx
import React, { useState, useEffect } from 'react';

const withLoader = (WrappedComponent) => {
  return (props) => {
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      setTimeout(() => setLoading(false), 2000);
    }, []);

    if (loading) {
      return <div>Loading...</div>;
    }

    return <WrappedComponent {...props} />;
  };
};

const UserComponent = () => <div>User Data</div>;

const UserWithLoader = withLoader(UserComponent);

export default UserWithLoader;
```

`withLoader` enhances `UserComponent` by showing a loading indicator before rendering the user data.

---

### 34. ReactJS - Higher Order Components (Part 2)

- **Concepts Covered**:
 - More examples of HOCs, such as adding authentication checks to components.

- **Example**:
  Creating an `withAuth` HOC that ensures the user is authenticated:

```jsx
const withAuth = (WrappedComponent) => {
  return (props) => {
    const isAuthenticated = false; // Replace with actual auth check

    if (!isAuthenticated) {
      return <div>Please log in to access this page.</div>;
    }

    return <WrappedComponent {...props} />;
  };
};

const Dashboard = () => <div>Dashboard</div>;

const ProtectedDashboard = withAuth(Dashboard);

export default ProtectedDashboard;
```

`withAuth` wraps `Dashboard` and ensures the user is logged in before rendering.

---

### 35. ReactJS - Higher Order Components (Part 3)

- **Concepts Covered**:
 - Handling more complex scenarios with HOCs, like error handling.

- **Example**:
  Creating a `withErrorHandler` HOC to handle errors in the wrapped component:

```jsx
import React from 'react';

const withErrorHandler = (WrappedComponent) => {
  return (props) => {
    try {
      return <WrappedComponent {...props} />;
    } catch (error) {
      return <div>Error occurred: {error.message}</div>;
    }
  };
};

const SomeComponent = () => {
  throw new Error('An error occurred!');
};

const SafeComponent = withErrorHandler(SomeComponent);

export default SafeComponent;
```

This HOC catches errors in `SomeComponent` and displays an error message instead of crashing the app.

---

### 36. ReactJS - Render Props (Part 1)

- **Concepts Covered**:
 - Introduction to the Render Props pattern, where a component receives a function as a prop and calls it to render dynamic content.

- **Example**:
  Creating a `MouseTracker` component using Render Props:

```jsx
class MouseTracker extends React.Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (e) => {
    this.setState({ x: e.clientX, y: e.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove}>
        {this.props.render(this.state)}
      </div>
    );
  }
}

const App = () => (
  <MouseTracker render={({ x, y }) => (
    <h1>Mouse Position: {x}, {y}</h1>
  )} />
);

export default App;
```

Here, `MouseTracker` uses the `render` prop to dynamically display the mouse position.

---

It looks like I still haven’t completed the full series! Let's continue from where we left off and finish up with the rest of the ReactJS tutorial topics.

---

### 37. ReactJS - Render Props (Part 2)

- **Concepts Covered**:
 - Advanced techniques using Render Props to pass dynamic props to child components.
 - Using render props to handle dynamic content or actions (like fetching data).

- **Example**:
  Passing a dynamic prop to a child component using render props:

```jsx
class DataFetcher extends React.Component {
  state = { data: null };

  componentDidMount() {
    fetch(this.props.url)
      .then((response) => response.json())
      .then((data) => this.setState({ data }));
  }

  render() {
    return this.props.render(this.state.data);
  }
}

const App = () => (
  <DataFetcher url="https://jsonplaceholder.typicode.com/posts/1" render={(data) => (
    <div>
      <h1>{data ? data.title : 'Loading...'}</h1>
    </div>
  )} />
);

export default App;
```

In this case, `DataFetcher` fetches data and passes it to the child component through the render prop. The child component dynamically displays the data once it's fetched.

---

### 38. ReactJS - Context (Part 1)

- **Concepts Covered**:
 - Introduction to the React Context API.
 - Context is a way to share data (like a global state) across multiple components without passing props down manually through each level.

- **Example**:
  Using the Context API to share a theme across components:

```jsx
import React, { createContext, useState } from 'react';

// Create context
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => (
  <ThemeContext.Consumer>
    {({ theme, setTheme }) => (
      <div style={{ background: theme === 'dark' ? 'black' : 'white', color: theme === 'dark' ? 'white' : 'black' }}>
        <p>Current theme: {theme}</p>
        <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>Toggle Theme</button>
      </div>
    )}
  </ThemeContext.Consumer>
);

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);

export default App;
```

In this example, `ThemeContext` allows components to access and update the theme globally without prop drilling.

---

### 39. ReactJS - Context (Part 2)

- **Concepts Covered**:
 - Consuming context in functional components using the `useContext` hook.

- **Example**:
  Using `useContext` to access context values:

```jsx
import React, { createContext, useState, useContext } from 'react';

const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'dark' ? 'black' : 'white', color: theme === 'dark' ? 'white' : 'black' }}>
      <p>Current theme: {theme}</p>
      <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);

export default App;
```

`useContext` is a cleaner, modern way to access context values, replacing the `Consumer` component from the previous example.

---

### 40. ReactJS 0 - Context (Part 3)

- **Concepts Covered**:
 - Advanced context patterns: Updating context dynamically in a component.

- **Example**:
  Updating the context dynamically within a component:

```jsx
import React, { createContext, useState, useContext } from 'react';

const UserContext = createContext();

const UserProvider = ({ children }) => {
  const [user, setUser] = useState({ name: 'John Doe' });

  const updateUser = (newName) => setUser({ name: newName });

  return (
    <UserContext.Provider value={{ user, updateUser }}>
      {children}
    </UserContext.Provider>
  );
};

const Profile = () => {
  const { user, updateUser } = useContext(UserContext);
  return (
    <div>
      <p>Name: {user.name}</p>
      <button onClick={() => updateUser('Jane Smith')}>Change Name</button>
    </div>
  );
};

const App = () => (
  <UserProvider>
    <Profile />
  </UserProvider>
);

export default App;
```

Here, the `UserContext` allows multiple components to access and update the shared `user` state.

---

### 41. ReactJS 1 - HTTP and React

- **Concepts Covered**:
 - Making HTTP requests in React using `fetch` or `axios`.
 - Handling API requests to fetch data or send data.

- **Example**:
  Fetching data from an API using `fetch`:

```jsx
import React, { useState, useEffect } from 'react';

const App = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []);

  return (
    <div>
      {data ? <h1>{data.title}</h1> : <p>Loading...</p>}
    </div>
  );
};

export default App;
```

This example demonstrates how to fetch and display data from an API inside a React component.

---

### 42. ReactJS 2 - HTTP GET Request

- **Concepts Covered**:
 - Handling GET requests in React to retrieve data from a server or public API.

- **Example**:
  Making a GET request using `axios`:

```jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => setData(response.data));
  }, []);

  return (
    <div>
      {data ? <h1>{data.title}</h1> : <p>Loading...</p>}
    </div>
  );
};

export default App;
```

Here, we use `axios` to make an HTTP GET request and display the retrieved data.

---

### 43. ReactJS 3 - HTTP Post Request

- **Concepts Covered**:
 - Handling POST requests in React to send data to a server.

- **Example**:
  Sending data using a POST request with `axios`:

```jsx
import React, { useState } from 'react';
import axios from 'axios';

const App = () => {
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    axios.post('https://jsonplaceholder.typicode.com/posts', { name })
      .then((response) => {
        console.log('Data posted:', response.data);
      });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text" 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
        placeholder="Enter name" 
      />
      <button type="submit">Submit</button>
    </form>
  );
};

export default App;
```

This example sends a POST request with form data to an API using `axios`.

---

### **React Hooks Series**

---

#### 44. React Hooks - Introduction

- **Concepts Covered**:
 - Introduction to React Hooks, and why they were introduced.
 - Hooks provide a way to use state and lifecycle methods in functional components.
 - Hooks help simplify code by allowing components to manage state, side effects, and context without the need for class components.

- **Example**:
  Transition from a class component to a functional component using `useState`:

```jsx
// Before (class component)
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

// After (functional component with hooks)
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 45. React Hooks - useState Hook

- **Concepts Covered**:
 - Using the `useState` hook to add state to functional components.
 - `useState` returns an array: the current state value and a function to update it.

- **Example**: A simple counter app using `useState`.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 46. React Hooks - useState with Previous State

- **Concepts Covered**:
 - Updating state based on the previous state using `useState`.
 - It's important to use the callback version of the state setter function when updating based on the current state.

- **Example**: Incrementing the counter with the previous state value.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount((prevCount) => prevCount + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 47. React Hooks - useState with Object

- **Concepts Covered**:
 - Storing and updating objects using `useState`.
 - To update specific properties of an object, use the spread operator to maintain the previous state.

- **Example**: Updating user profile information stored as an object.

```jsx
const UserProfile = () => {
  const [user, setUser] = useState({ name: 'John', age: 30 });

  const updateName = () => setUser((prevUser) => ({ ...prevUser, name: 'Jane' }));

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <button onClick={updateName}>Change Name</button>
    </div>
  );
};
```

---

#### 48. React Hooks - useState with Array

- **Concepts Covered**:
 - Storing arrays in state and updating array items using `useState`.
 - When updating arrays, make sure to create a new array using methods like `concat`, `slice`, or spread operator.

- **Example**: Adding/removing items from a list.

```jsx
const TodoList = () => {
  const [todos, setTodos] = useState([]);

  const addTodo = () => {
    const newTodo = prompt('Enter a new todo');
    setTodos((prevTodos) => [...prevTodos, newTodo]);
  };

  const removeTodo = (index) => {
    setTodos((prevTodos) => prevTodos.filter((_, i) => i !== index));
  };

  return (
    <div>
      <ul>
        {todos.map((todo, index) => (
          <li key={index}>
            {todo} <button onClick={() => removeTodo(index)}>Delete</button>
          </li>
        ))}
      </ul>
      <button onClick={addTodo}>Add Todo</button>
    </div>
  );
};
```

---

#### 49. React Hooks - useEffect Hook

- **Concepts Covered**:
 - `useEffect` hook allows you to perform side effects (e.g., data fetching, subscriptions) in functional components.
 - Runs after the component renders.

- **Example**: Fetching data in `useEffect` on component mount.

```jsx
import { useState, useEffect } from 'react';

const DataFetcher = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []); // Empty dependency array means it only runs once when the component mounts

  return <div>{data ? <h1>{data.title}</h1> : 'Loading...'}</div>;
};
```

---

#### 50. React Hooks - useEffect after Render

- **Concepts Covered**:
 - Running `useEffect` after every render to monitor state or props changes.
 - Useful for debugging or when side effects depend on dynamic state.

- **Example**: Debugging component renders with `useEffect`.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Component rendered or count changed:', count);
  });

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 51. React Hooks - Conditionally Run Effects

- **Concepts Covered**:
 - You can conditionally run effects based on state or props changes by specifying dependencies in the dependency array of `useEffect`.

- **Example**: Fetching data when a particular state changes.

```jsx
const FetchOnChange = () => {
  const [query, setQuery] = useState('');
  const [data, setData] = useState(null);

  useEffect(() => {
    if (query) {
      fetch(`https://api.example.com/search?q=${query}`)
        .then((response) => response.json())
        .then((data) => setData(data));
    }
  }, [query]); // Runs when query changes

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <div>{data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'No results'}</div>
    </div>
  );
};
```

---

#### 52. React Hooks - Run Effects Only Once

- **Concepts Covered**:
 - You can run `useEffect` only once when the component mounts by passing an empty dependency array `[]`.

- **Example**: Setting up event listeners or fetching data once on component mount.

```jsx
const Component = () => {
  useEffect(() => {
    console.log('Component mounted');
    // Setup or fetch data here
  }, []); // Runs only once on mount

  return <div>Component</div>;
};
```

---

#### 53. React Hooks - useEffect with Cleanup

- **Concepts Covered**:
 - Cleaning up side effects when the component unmounts using the return function inside `useEffect`.

- **Example**: Cleaning up a timer or subscription in `useEffect`.

```jsx
const Timer = () => {
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer running...');
    }, 1000);

    return () => {
      clearInterval(timer); // Cleanup the timer on component unmount
    };
  }, []);

  return <div>Timer component</div>;
};
```

---

It seems like you want to continue the list from where we left off. Here's the continuation of the React Hooks tutorials:

---

#### 54. React Hooks - useEffect with Incorrect Dependency

- **Concepts Covered**:
 - Common mistakes when using `useEffect` with dependencies.
 - How missing or incorrectly added dependencies can lead to bugs, infinite loops, or stale data.

- **Example**: Debugging dependency arrays in `useEffect` by ensuring proper state and prop tracking.

```jsx
const ExampleComponent = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // Incorrect: Forgetting to add 'count' as a dependency could cause stale data issues
  useEffect(() => {
    console.log(`Name: ${name}`);
  }, []); // Should include 'count' if it is part of the effect

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <p>{name}</p>
      <button onClick={() => setName('John')}>Change Name</button>
    </div>
  );
};
```

---

#### 55. React Hooks - Fetching Data with useEffect Part 1

- **Concepts Covered**:
 - Using `useEffect` to fetch data from an API when the component mounts.
 - Handling API responses inside `useEffect`.

- **Example**: Fetching data from an API and displaying the fetched data.

```jsx
const DataFetcher = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((jsonData) => setData(jsonData));
  }, []); // Runs once after initial render

  return <div>{data ? <h1>{data.title}</h1> : 'Loading...'}</div>;
};
```

---

#### 56. React Hooks - Fetching Data with useEffect Part 2

- **Concepts Covered**:
 - Handling loading, success, and error states when fetching data with `useEffect`.

- **Example**: Conditional rendering for loading and error handling.

```jsx
const FetchDataWithState = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((jsonData) => {
        setData(jsonData);
        setLoading(false);
      })
      .catch((error) => {
        setError(error);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{data && <h1>{data.title}</h1>}</div>;
};
```

---

#### 57. React Hooks - Fetching Data with useEffect Part 3

- **Concepts Covered**:
 - Optimizing multiple requests using `useEffect`.
 - Handling sequential or parallel API calls in `useEffect`.

- **Example**: Making multiple API requests simultaneously or sequentially.

```jsx
const FetchMultipleData = () => {
  const [posts, setPosts] = useState([]);
  const [user, setUser] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const postsRes = await fetch('https://jsonplaceholder.typicode.com/posts');
      const userRes = await fetch('https://jsonplaceholder.typicode.com/users/1');
      const postsData = await postsRes.json();
      const userData = await userRes.json();
      setPosts(postsData);
      setUser(userData);
    };

    fetchData();
  }, []);

  return (
    <div>
      {user && <h1>User: {user.name}</h1>}
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
};
```

---

#### 58. React Hooks - useContext Hook Part 1

- **Concepts Covered**:
 - Introduction to `useContext` for sharing global state across components.
 - Managing shared data like user authentication or theme state.

- **Example**: Sharing state between components using React Context.

```jsx
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  const toggleTheme = () => setTheme(theme === 'light' ? 'dark' : 'light');

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
      <p>The current theme is {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);
```

---

#### 59. React Hooks - useContext Hook Part 2

- **Concepts Covered**:
 - Updating context values dynamically and passing those values to components.

- **Example**: Changing theme (light/dark mode) across the app using context.

```jsx
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  const toggleTheme = () => setTheme((prev) => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'light' ? 'white' : 'gray', color: theme === 'light' ? 'black' : 'white' }}>
      <h1>Theme: {theme}</h1>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);
```

---

#### 60. React Hooks - useContext Hook Part 3

- **Concepts Covered**:
 - Combining `useContext` with other hooks like `useState` and `useEffect`.

- **Example**: Managing user authentication with `useContext`.

```jsx
const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  const login = (username) => setUser({ name: username });
  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

const UserProfile = () => {
  const { user, logout } = useContext(AuthContext);

  return user ? (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  ) : (
    <div>
      <p>Please login</p>
    </div>
  );
};

const App = () => (
  <AuthProvider>
    <UserProfile />
  </AuthProvider>
);
```

---

It seems like you're looking for more of the tutorial list. Here's the continuation from where we left off:

---

#### 61. React Hooks - useReducer Hook

- **Concepts Covered**:  
 - Introduction to `useReducer` for handling complex state logic.
 - When to use `useReducer` over `useState` for better control over state transitions.

- **Example**:  
 - Using `useReducer` to manage multi-step form logic or any complex state structure.

```jsx
const initialState = { step: 1, data: {} };

const formReducer = (state, action) => {
  switch (action.type) {
    case 'NEXT_STEP':
      return { ...state, step: state.step + 1 };
    case 'UPDATE_DATA':
      return { ...state, data: { ...state.data, ...action.payload } };
    default:
      return state;
  }
};

const FormComponent = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <h1>Step {state.step}</h1>
      <button onClick={() => dispatch({ type: 'NEXT_STEP' })}>Next Step</button>
      <button
        onClick={() =>
          dispatch({ type: 'UPDATE_DATA', payload: { name: 'John' } })
        }
      >
        Update Data
      </button>
    </div>
  );
};
```

---

#### 62. React Hooks - useReducer (Simple State & Action)

- **Concepts Covered**:  
 - Managing state transitions with `useReducer` for simple states and actions.

- **Example**:  
 - Implementing a simple counter with `useReducer`.

```jsx
const initialState = { count: 0 };

const counterReducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const CounterComponent = () => {
  const [state, dispatch] = useReducer(counterReducer, initialState);

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
    </div>
  );
};
```

---

#### 63. React Hooks - useReducer (Complex State & Action)

- **Concepts Covered**:  
 - Managing more complex states and actions with `useReducer`.

- **Example**:  
 - Using `useReducer` to handle form states with multiple inputs.

```jsx
const initialState = { name: '', email: '' };

const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    case 'UPDATE_EMAIL':
      return { ...state, email: action.payload };
    default:
      return state;
  }
};

const FormComponent = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <input
        type="text"
        value={state.name}
        onChange={(e) => dispatch({ type: 'UPDATE_NAME', payload: e.target.value })}
        placeholder="Name"
      />
      <input
        type="email"
        value={state.email}
        onChange={(e) => dispatch({ type: 'UPDATE_EMAIL', payload: e.target.value })}
        placeholder="Email"
      />
    </div>
  );
};
```

---

#### 64. React Hooks - Multiple useReducers

- **Concepts Covered**:  
 - Using multiple `useReducer` hooks within one component for separate pieces of state.

- **Example**:  
 - Combining two reducers for different pieces of state, such as managing a form and UI states.

```jsx
const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    default:
      return state;
  }
};

const uiReducer = (state, action) => {
  switch (action.type) {
    case 'TOGGLE_MODAL':
      return { ...state, showModal: !state.showModal };
    default:
      return state;
  }
};

const FormWithModal = () => {
  const [formState, dispatchForm] = useReducer(formReducer, { name: '' });
  const [uiState, dispatchUI] = useReducer(uiReducer, { showModal: false });

  return (
    <div>
      <input
        type="text"
        value={formState.name}
        onChange={(e) => dispatchForm({ type: 'UPDATE_NAME', payload: e.target.value })}
        placeholder="Name"
      />
      <button onClick={() => dispatchUI({ type: 'TOGGLE_MODAL' })}>
        Toggle Modal
      </button>
      {uiState.showModal && <div>Modal Content</div>}
    </div>
  );
};
```

---

#### 65. React Hooks - useReducer with useContext

- **Concepts Covered**:  
 - Combining `useReducer` with `useContext` to manage application-wide state.

- **Example**:  
 - Sharing form and UI states across components using both hooks.

```jsx
const StateContext = createContext();

const initialState = { name: '', showModal: false };

const reducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    case 'TOGGLE_MODAL':
      return { ...state, showModal: !state.showModal };
    default:
      return state;
  }
};

const StateProvider = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <StateContext.Provider value={{ state, dispatch }}>
      {children}
    </StateContext.Provider>
  );
};

const NameInput = () => {
  const { state, dispatch } = useContext(StateContext);
  return (
    <input
      type="text"
      value={state.name}
      onChange={(e) => dispatch({ type: 'UPDATE_NAME', payload: e.target.value })}
      placeholder="Name"
    />
  );
};

const ModalToggle = () => {
  const { state, dispatch } = useContext(StateContext);
  return (
    <button onClick={() => dispatch({ type: 'TOGGLE_MODAL' })}>
      Toggle Modal
    </button>
  );
};

const App = () => (
  <StateProvider>
    <NameInput />
    <ModalToggle />
    {state.showModal && <div>Modal Content</div>}
  </StateProvider>
);
```

---

#### 66. React Hooks - Fetching Data with useReducer Part 1

- **Concepts Covered**:  
 - Using `useReducer` to manage fetching data and the associated loading, error, and success states.

- **Example**:  
 - Fetching data with complex state transitions (loading, error, success).

```jsx
const initialState = { loading: true, data: null, error: null };

const fetchReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { loading: false, data: action.payload, error: null };
    case 'FETCH_ERROR':
      return { loading: false, data: null, error: action.error };
    default:
      return state;
  }
};

const FetchDataComponent = () => {
  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts')
      .then((response) => response.json())
      .then((data) => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
      .catch((error) => dispatch({ type: 'FETCH_ERROR', error: error.message }));
  }, []);

  if (state.loading) return <div>Loading...</div>;
  if (state.error) return <div>Error: {state.error}</div>;

  return <ul>{state.data.map((post) => <li key={post.id}>{post.title}</li>)}</ul>;
};
```

---

It seems like you're still looking for more information from the list. I'll provide the continuation from where we left off:

---

#### 67. React Hooks - Fetching Data with useReducer Part 2

- **Concepts Covered**:  
 - Advanced error handling and optimization when using `useReducer` for fetching data.

- **Example**:  
 - Handling retries for failed fetch requests and managing multiple states (loading, success, error).

```jsx
const initialState = { loading: true, data: null, error: null, retryCount: 0 };

const fetchReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { loading: false, data: action.payload, error: null, retryCount: 0 };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.error };
    case 'RETRY_FETCH':
      return { ...state, retryCount: state.retryCount + 1, loading: true };
    default:
      return state;
  }
};

const FetchDataWithRetry = () => {
  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() => {
    const fetchData = () => {
      fetch('https://jsonplaceholder.typicode.com/posts')
        .then((response) => response.json())
        .then((data) => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
        .catch((error) => dispatch({ type: 'FETCH_ERROR', error: error.message }));
    };

    fetchData();
  }, [state.retryCount]);

  if (state.loading) return <div>Loading...</div>;
  if (state.error) {
    return (
      <div>
        Error: {state.error}
        <button onClick={() => dispatch({ type: 'RETRY_FETCH' })}>Retry</button>
      </div>
    );
  }

  return <ul>{state.data.map((post) => <li key={post.id}>{post.title}</li>)}</ul>;
};
```

---

#### 68. React Hooks - useState vs useReducer

- **Concepts Covered**:  
 - Comparing `useState` and `useReducer` for state management and when to use each.

- **Example**:  
 - Using `useState` for simple state management, and `useReducer` for complex state logic.

```jsx
// Using useState for simple state
const CounterWithState = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

// Using useReducer for complex state
const initialState = { count: 0, step: 1 };

const reducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + state.step };
    case 'SET_STEP':
      return { ...state, step: action.payload };
    default:
      return state;
  }
};

const CounterWithReducer = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'SET_STEP', payload: 2 })}>Set Step to 2</button>
    </div>
  );
};
```

---

#### 69. React Hooks - useCallback Hook

- **Concepts Covered**:  
 - Using `useCallback` to memoize functions and prevent unnecessary re-renders.
 - Optimizing performance by memoizing callbacks that are passed to child components.

- **Example**:  
 - Using `useCallback` to memoize a function for a button click handler.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return <ChildComponent increment={increment} />;
};

const ChildComponent = React.memo(({ increment }) => {
  console.log('Child component rendered');
  return <button onClick={increment}>Increment</button>;
});
```

---

#### 70. React Hooks - useMemo Hook

- **Concepts Covered**:  
 - Using `useMemo` to memoize expensive computations and avoid re-calculating on every render.

- **Example**:  
 - Optimizing complex calculations using `useMemo`.

```jsx
const ExpensiveComponent = ({ num }) => {
  const computeExpensiveValue = (num) => {
    console.log('Computing...');
    return num * 1000;
  };

  const memoizedValue = useMemo(() => computeExpensiveValue(num), [num]);

  return <div>Computed Value: {memoizedValue}</div>;
};
```

---

#### 71. React Hooks - useRef Hook Part 1

- **Concepts Covered**:  
 - Introduction to `useRef` for accessing DOM elements and storing mutable values that persist across renders.

- **Example**:  
 - Managing focus on an input element using `useRef`.

```jsx
const FocusInput = () => {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};
```

---

#### 72. React Hooks - useRef Hook Part 2

- **Concepts Covered**:  
 - Advanced usage of `useRef`, such as storing mutable values that persist across renders.

- **Example**:  
 - Storing a previous state value using `useRef`.

```jsx
const PreviousState = () => {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  return (
    <div>
      <h1>Current Count: {count}</h1>
      <h2>Previous Count: {prevCountRef.current}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 73. React Hooks - Custom Hooks

- **Concepts Covered**:  
 - Introduction to creating custom hooks to encapsulate reusable logic.

- **Example**:  
 - Creating a custom hook to handle window resizing.

```jsx
const useWindowSize = () => {
  const [size, setSize] = useState([window.innerWidth, window.innerHeight]);

  useEffect(() => {
    const handleResize = () => {
      setSize([window.innerWidth, window.innerHeight]);
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return size;
};

const WindowSizeComponent = () => {
  const [width, height] = useWindowSize();

  return (
    <div>
      <h1>Window Size</h1>
      <p>Width: {width}</p>
      <p>Height: {height}</p>
    </div>
  );
};
```

---

#### 74. React Hooks - useDocumentTitle Custom Hook

- **Concepts Covered**:  
 - Example of a custom hook to update the document title dynamically.

- **Example**:  
 - Creating a `useDocumentTitle` custom hook to change the page title.

```jsx
const useDocumentTitle = (title) => {
  useEffect(() => {
    document.title = title;
  }, [title]);
};

const PageComponent = () => {
  const [pageTitle, setPageTitle] = useState('Home');

  useDocumentTitle(pageTitle);

  return (
    <div>
      <h1>{pageTitle}</h1>
      <button onClick={() => setPageTitle('About')}>Change Title</button>
    </div>
  );
};
```

---

#### 75. React Hooks - useCounter Custom Hook

- **Concepts Covered**:  
 - Using a custom hook to manage counter logic.

- **Example**:  
 - Creating a reusable counter hook.

```jsx
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return { count, increment, decrement };
};

const CounterComponent = () => {
  const { count, increment, decrement } = useCounter(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};
```

---

#### 76. React Hooks - useInput

 Custom Hook

- **Concepts Covered**:  
 - Creating a custom hook to manage form input logic.

- **Example**:  
 - Reusable `useInput` hook to handle form input values.

```jsx
const useInput = (initialValue = '') => {
  const [value, setValue] = useState(initialValue);

  const handleChange = (e) => setValue(e.target.value);

  return { value, handleChange };
};

const FormComponent = () => {
  const nameInput = useInput('');
  const emailInput = useInput('');

  return (
    <form>
      <input {...nameInput} placeholder="Name" />
      <input {...emailInput} placeholder="Email" />
    </form>
  );
};
```

---

Here’s the continuation of your **React Render Series**:

---

#### 77. React Render - Introduction

- **Concepts Covered**:  
 - Introduction to React rendering behavior.
 - Understanding how React optimizes rendering and the concept of reconciliation.

- **Example**:  
 - Explaining the basic lifecycle of rendering and re-rendering in React components.

---

#### 78. React Render - Rendering

- **Concepts Covered**:  
 - How React renders UI and the process of creating a virtual DOM to optimize updates.
 - Reconciliation: React’s algorithm for matching updates to the virtual DOM with the actual DOM.

- **Example**:  
 - Rendering components in a React app and the process of state/prop change triggering a re-render.

```jsx
const MyComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 79. React Render - useState

- **Concepts Covered**:  
 - Understanding how `useState` triggers re-renders when state is updated.
 - The connection between state updates and component re-renders.

- **Example**:  
 - A counter app that demonstrates how `useState` causes the component to re-render on state change.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Current count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 80. React Render - useReducer

- **Concepts Covered**:  
 - Exploring `useReducer` for managing more complex state logic.
 - Understanding how `useReducer` interacts with re-renders.

- **Example**:  
 - A simple counter with `useReducer`, showing how state updates lead to re-renders.

```jsx
const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const CounterWithReducer = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
    </div>
  );
};
```

---

#### 81. React Render - State Immutability

- **Concepts Covered**:  
 - Why state in React must be treated as immutable to ensure proper rendering behavior.
 - Best practices to ensure that React detects state changes.

- **Example**:  
 - Proper and improper ways to update state and how it affects re-renders.

```jsx
// Correct: using spread syntax to update an object
const [state, setState] = useState({ count: 0 });
const increment = () => setState((prevState) => ({ ...prevState, count: prevState.count + 1 }));

// Incorrect: mutating the state directly
const incrementWrong = () => state.count++;
```

---

#### 82. React Render - Parent and Child

- **Concepts Covered**:  
 - How re-renders in parent and child components work in React.
 - Optimizing performance when parent or child components re-render unnecessarily.

- **Example**:  
 - Parent component rendering with child components and handling unnecessary re-renders.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Parent Count: {count}</p>
      <ChildComponent />
      <button onClick={() => setCount(count + 1)}>Increment Parent</button>
    </div>
  );
};

const ChildComponent = React.memo(() => {
  return <div>Child Component</div>;
});
```

---

#### 83. React Render - Same Element Reference

- **Concepts Covered**:  
 - When React recognizes the same element reference and prevents unnecessary re-renders.
 - Understanding React's rendering optimizations.

- **Example**:  
 - Comparing cases where React can avoid re-rendering the same component with the same element reference.

```jsx
const Component = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      <button onClick={() => setValue(value + 1)}>Increment</button>
      {value > 5 && <p>Value is greater than 5</p>}
    </div>
  );
};
```

---

#### 84. React Render - React memo

- **Concepts Covered**:  
 - Using `React.memo` to memoize a component and prevent unnecessary re-renders.
 - How `React.memo` works and its effect on functional components.

- **Example**:  
 - Memoizing a component to prevent re-render when props don’t change.

```jsx
const ChildComponent = React.memo(({ name }) => {
  console.log('Child rendered');
  return <p>{name}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <ChildComponent name="John" />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 85. React Render - Questions on Optimization

- **Concepts Covered**:  
 - Common questions on React rendering optimizations, including unnecessary renders, memoization, and use of hooks.

- **Example**:  
 - Identifying when and where to optimize React components for performance.

```jsx
const MemoizedComponent = React.memo(({ value }) => {
  console.log('Rendered Memoized Component');
  return <p>{value}</p>;
});

const ParentComponent = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      <MemoizedComponent value={value} />
      <button onClick={() => setValue(value + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 86. React Render - Incorrect memo with children

- **Concepts Covered**:  
 - Potential issues with `React.memo` when used with child components that receive dynamic props.

- **Example**:  
 - A demonstration of how `React.memo` might not be effective when children receive new props on each render.

```jsx
const ChildComponent = React.memo(({ value }) => {
  console.log('Child rendered');
  return <p>{value}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const value = { id: 1 };

  return (
    <div>
      <ChildComponent value={value} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 87. React Render - Incorrect memo with Impure Component

- **Concepts Covered**:  
 - Why `React.memo` might not optimize performance for impure components that have side effects or rely on external states.

- **Example**:  
 - Using `React.memo` incorrectly with impure components.

```jsx
const ImpureComponent = ({ count }) => {
  console.log('Rendered Impure Component');
  return <p>{count}</p>;
};

const MemoizedImpureComponent = React.memo(ImpureComponent);

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <MemoizedImpureComponent count={count} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 88. React Render - Incorrect memo with props Reference

- **Concepts Covered**:  
 - Issues with `React.memo` when props are passed by reference (e.g., objects, arrays).

- **Example**:  
 - Demonstrating when React.memo will not prevent re-renders due to reference equality checks.

```jsx
const ChildComponent = React.memo(({ data }) => {
  console.log('Child rendered');
  return <p>{data.name}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = { name: 'John' };

  return (
    <div>
      <ChildComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 89. React Render - useMemo and useCallback

- **Concepts Covered**:  
 - Using `

useMemo` and `useCallback` to memoize values and functions to optimize rendering.

- **Example**:  
 - Memoizing a callback function using `useCallback` and an expensive calculation with `useMemo`.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const memoizedCallback = useCallback(() => {
    console.log('Memoized callback');
  }, []);

  const memoizedValue = useMemo(() => count * 2, [count]);

  return (
    <div>
      <p>Memoized Value: {memoizedValue}</p>
      <button onClick={memoizedCallback}>Memoized Callback</button>
    </div>
  );
};
```

---

#### 90. React Render - Context

- **Concepts Covered**:  
 - Understanding how Context affects re-renders in React components.
 - Avoiding unnecessary re-renders with Context.

- **Example**:  
 - Using `useContext` to access global state without causing re-renders in unrelated components.

```jsx
const ThemeContext = React.createContext();

const ParentComponent = () => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={theme}>
      <ChildComponent />
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>Toggle Theme</button>
    </ThemeContext.Provider>
  );
};

const ChildComponent = () => {
  const theme = useContext(ThemeContext);
  return <div>The theme is {theme}</div>;
};
```

---

#### 91. React Render - Context and memo

- **Concepts Covered**:  
 - Using `React.memo` with Context to prevent unnecessary re-renders.

- **Example**:  
 - Optimizing performance when combining `React.memo` and `useContext`.

```jsx
const MemoizedComponent = React.memo(() => {
  const theme = useContext(ThemeContext);
  return <div>Theme: {theme}</div>;
});
```

---

#### 92. React Render - Context and Same Element Reference

- **Concepts Covered**:  
 - How React re-renders components when the element reference remains the same, even in Context-based applications.

- **Example**:  
 - Understanding how `React.memo` and Context work together to avoid re-renders with unchanged references.

---

Here's the continuation of your **React TypeScript Series**:

---

#### 93. React TypeScript - Introduction

- **Concepts Covered**:  
 - Introduction to React with TypeScript.
 - Setting up TypeScript with a React project.
 - Benefits of using TypeScript in React: type safety, autocompletion, and easier refactoring.

- **Example**:  
 - Setting up a new React project with TypeScript using `create-react-app`.

```bash
npx create-react-app my-app --template typescript
```

---

#### 94. React TypeScript - Getting Started

- **Concepts Covered**:  
 - Getting started with TypeScript in React, and understanding the basics of type safety within JSX.
 - How TypeScript enhances React development by adding types to JSX components.

- **Example**:  
 - Writing a simple functional component in TypeScript.

```tsx
import React from 'react';

interface GreetingProps {
  name: string;
}

const Greeting: React.FC<GreetingProps> = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

export default Greeting;
```

---

#### 95. React TypeScript - Typing Props

- **Concepts Covered**:  
 - How to define types for props in TypeScript for React components.
 - Using interfaces to define the shape of props passed to functional components.

- **Example**:  
 - Typing props in a functional component using an interface.

```tsx
interface ButtonProps {
  label: string;
  onClick: () => void;
}

const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

---

#### 96. React TypeScript - Basic Props

- **Concepts Covered**:  
 - Basic prop types in React with TypeScript such as `string`, `number`, `boolean`, and `ReactNode`.
 - Understanding how to specify these basic types to ensure type safety.

- **Example**:  
 - Typing props with simple types like `string`, `number`, and `boolean`.

```tsx
interface CardProps {
  title: string;
  count: number;
  isVisible: boolean;
}

const Card: React.FC<CardProps> = ({ title, count, isVisible }) => {
  return isVisible ? (
    <div>
      <h2>{title}</h2>
      <p>{count}</p>
    </div>
  ) : null;
};
```

---

#### 97. React TypeScript - Advanced Props

- **Concepts Covered**:  
 - Advanced props such as optional props, default props, and function props.
 - How to make props optional or provide default values using TypeScript.

- **Example**:  
 - Typing components that accept function props or optional props.

```tsx
interface ButtonProps {
  onClick: () => void;
  color?: string;  // Optional prop
}

const Button: React.FC<ButtonProps> = ({ onClick, color = 'blue' }) => {
  return <button style={{ backgroundColor: color }} onClick={onClick}>Click me</button>;
};
```

---

#### 98. React TypeScript - Event Props

- **Concepts Covered**:  
 - Typing event props such as `onClick`, `onChange`, `onSubmit`, and others in React components.
 - Understanding how to type event handlers in TypeScript.

- **Example**:  
 - Typing `onClick` and `onChange` event handlers in a React component.

```tsx
interface FormProps {
  onSubmit: (value: string) => void;
}

const Form: React.FC<FormProps> = ({ onSubmit }) => {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(event.target.value);
  };

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    onSubmit(inputValue);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" value={inputValue} onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
};
```

---

#### 99. React TypeScript - Style Props

- **Concepts Covered**:  
 - Typing inline style props in React components using TypeScript.
 - Using the `CSSProperties` type from `react` for typing inline styles.

- **Example**:  
 - Typing the `style` attribute when applying inline styles to a component.

```tsx
import React, { CSSProperties } from 'react';

interface BoxProps {
  style?: CSSProperties;
}

const Box: React.FC<BoxProps> = ({ style }) => {
  return <div style={style}>This is a box!</div>;
};

// Usage
<Box style={{ backgroundColor: 'red', width: '100px', height: '100px' }} />
```

---

#### 100. React TypeScript - Prop Types and Tips

- **Concepts Covered**:  
 - Using `PropTypes` in addition to TypeScript for runtime prop validation.
 - Understanding the difference between static typing with TypeScript and runtime validation with PropTypes.

- **Example**:  
 - Combining TypeScript and PropTypes for validation of component props.

```tsx
import PropTypes from 'prop-types';

interface GreetingProps {
  name: string;
}

const Greeting: React.FC<GreetingProps> = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

Greeting.propTypes = {
  name: PropTypes.string.isRequired
};

export default Greeting;
```

---

Here is the continuation of your **React TypeScript Series**:

---

#### 101. React TypeScript - useState Hook

- **Concepts Covered**:
 - Typing `useState` in TypeScript, handling different types of state, including primitive values, objects, and arrays.
 - Ensuring type safety for state variables, and understanding how TypeScript enhances the use of `useState`.

- **Example**:  
 - Defining types for state variables using `useState` with different types.

```tsx
import React, { useState } from 'react';

const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0);
  
  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 102. React TypeScript - useState Future Value

- **Concepts Covered**:
 - Typing future state values and understanding asynchronous state updates.
 - Handling async logic in `useState`, such as when state is updated based on previous state values.

- **Example**:  
 - Handling async logic with `useState` in TypeScript.

```tsx
const [count, setCount] = useState<number>(0);

const incrementAsync = () => {
  setTimeout(() => {
    setCount(prev => prev + 1);
  }, 1000);
};
```

---

#### 103. React TypeScript - useState Type Assertion

- **Concepts Covered**:  
 - Using type assertions with `useState` to ensure specific types when TypeScript is unable to infer the type.
 - Casting state variables to a specific type to avoid errors or warnings.

- **Example**:  
 - Using type assertions to specify the type of state.

```tsx
const [value, setValue] = useState(''); // TypeScript infers value as string
const [count, setCount] = useState<number | null>(null);

setCount(5 as number); // Type assertion to tell TypeScript it's a number
```

---

#### 104. React TypeScript - useReducer Hook

- **Concepts Covered**:  
 - Typing the `useReducer` hook for more complex state logic, especially with action creators and state updates.
 - Using TypeScript with `useReducer` to ensure action and state types are strictly followed.

- **Example**:  
 - Managing state with `useReducer` and typing actions and state updates.

```tsx
interface State {
  count: number;
}

type Action = { type: 'increment' } | { type: 'decrement' };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const Counter: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
};
```

---

#### 105. React TypeScript - useReducer Strict Action Types

- **Concepts Covered**:  
 - Ensuring strict action types in `useReducer` to avoid accidentally passing in wrong action types and to improve type safety.

- **Example**:  
 - Making sure actions are strictly typed when using `useReducer`.

```tsx
type Action = 
  | { type: 'increment' }
  | { type: 'decrement' };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error('Unknown action type');
  }
};
```

---

#### 106. React TypeScript - useContext Hook

- **Concepts Covered**:  
 - Typing the `useContext` hook in TypeScript to ensure the context values are correctly typed and provide type safety for global state management.

- **Example**:  
 - Typing `useContext` with `createContext` to manage global state.

```tsx
interface ThemeContextProps {
  theme: string;
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextProps | undefined>(undefined);

const ThemeProvider: React.FC = ({ children }) => {
  const [theme, setTheme] = useState<string>('light');
  
  const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent: React.FC = () => {
  const context = useContext(ThemeContext);
  
  if (!context) {
    throw new Error('useContext must be used within a ThemeProvider');
  }
  
  return <div>{context.theme} mode</div>;
};
```

---

#### 107. React TypeScript - useContext Future Value

- **Concepts Covered**:  
 - Handling and typing async data inside `useContext` and managing dynamic values like API responses or future values.

- **Example**:  
 - Using `useContext` with asynchronous data.

```tsx
const DataContext = React.createContext<string | undefined>(undefined);

const DataProvider: React.FC = ({ children }) => {
  const [data, setData] = useState<string | undefined>(undefined);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    const response = await fetch('https://api.example.com/data');
    const result = await response.json();
    setData(result.data);
  };

  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
};
```

---

#### 108. React TypeScript - useRef Hook

- **Concepts Covered**:  
 - Typing the `useRef` hook in TypeScript to access DOM elements and manage mutable state.
 - Using `useRef` for direct DOM manipulation, while ensuring type safety.

- **Example**:  
 - Typing `useRef` to access DOM elements like input fields or divs.

```tsx
const InputFocus: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};
```

---

#### 109. React TypeScript - Class Component

- **Concepts Covered**:  
 - Typing class components in TypeScript, including the types for props, state, and methods.
 - How to work with TypeScript to type class component lifecycle methods.

- **Example**:  
 - A class-based component with typed props and state.

```tsx
interface CounterProps {
  initialCount: number;
}

interface CounterState {
  count: number;
}

class Counter extends React.Component<CounterProps, CounterState> {
  constructor(props: CounterProps) {
    super(props);
    this.state = { count: props.initialCount };
  }

  increment = () => {
    this.setState(prevState => ({ count: prevState.count + 1 }));
  };

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

---

#### 110. React TypeScript - Component Prop

- **Concepts Covered**:  
 - Defining and typing props in class components with TypeScript.
 - How to work with props in a typed class component.

- **Example**:  
 - A class-based component that receives props.

```tsx
interface ButtonProps {
  label: string;
}

class Button extends React.Component<ButtonProps> {
  render() {
    return <button>{this.props.label}</button>;
  }
}
```

---

Here’s the continuation of the **React TypeScript Series**:

---

#### 111. React TypeScript - Generic Props

- **Concepts Covered**:  
 - Using TypeScript generics for props to create reusable components with dynamic prop types.
 - How generics allow for flexibility and type safety when passing props to components.

- **Example**:  
 - A generic component that can accept props of any type.

```tsx
interface BoxProps<T> {
  value: T;
}

function Box<T>({ value }: BoxProps<T>) {
  return <div>{value}</div>;
}

// Using with different types
const App = () => (
  <>
    <Box value="Hello, world!" />
    <Box value={42} />
  </>
);
```

---

#### 112. React TypeScript - Restricting Props

- **Concepts Covered**:  
 - Restricting the type of props passed into a component using TypeScript.
 - Using union types, enums, or literal types to limit which types are allowed.

- **Example**:  
 - Creating stricter prop types to limit the allowed types.

```tsx
type ButtonProps = {
  color: 'primary' | 'secondary';  // Restricting to specific strings
  onClick: () => void;
};

const Button: React.FC<ButtonProps> = ({ color, onClick }) => (
  <button className={color} onClick={onClick}>
    Click me
  </button>
);
```

---

#### 113. React TypeScript - Template Literals and Exclude

- **Concepts Covered**:  
 - Using TypeScript’s `Exclude` utility type to manage types dynamically.
 - Combining template literals with `Exclude` to create flexible type constraints for props.

- **Example**:  
 - Dynamically restricting prop types using `Exclude` with template literals.

```tsx
type ButtonProps = {
  size: 'small' | 'medium' | 'large';
  color: 'red' | 'blue' | 'green';
};

type ExcludeSize = Exclude<ButtonProps['size'], 'small'>;

const Button: React.FC<ButtonProps> = ({ size, color }) => (
  <button style={{ fontSize: size === 'small' ? '12px' : '16px', color }}>
    Click me
  </button>
);
```

---

#### 114. React TypeScript - Wrapping HTML Elements

- **Concepts Covered**:  
 - Creating custom components that wrap around standard HTML elements while ensuring proper typing.
 - Using the `React.HTMLProps` interface to pass through standard props from a native HTML element.

- **Example**:  
 - Wrapping an HTML `div` element inside a custom component and typing the props.

```tsx
interface MyDivProps extends React.HTMLProps<HTMLDivElement> {
  customStyle: string;
}

const MyDiv: React.FC<MyDivProps> = ({ customStyle, ...props }) => {
  return <div style={{ backgroundColor: customStyle }} {...props} />;
};

// Usage
<MyDiv customStyle="lightblue" className="my-class">
  Content goes here
</MyDiv>;
```

---

#### 115. React TypeScript - Extracting a Component's Prop Types

- **Concepts Covered**:  
 - Extracting prop types from one component and reusing them in another component to ensure consistency.
 - Using `React.ComponentProps` to extract the types of props from a component.

- **Example**:  
 - Reusing prop types from another component using `React.ComponentProps`.

```tsx
const Button: React.FC<{ label: string }> = ({ label }) => <button>{label}</button>;

type ButtonProps = React.ComponentProps<typeof Button>;  // Extracts props from Button

const AnotherButton: React.FC<ButtonProps> = (props) => <button {...props} />;
```

---

#### 116. React TypeScript - Polymorphic Components

- **Concepts Covered**:  
 - Creating polymorphic components that can accept different types of HTML tags as children.
 - Typing polymorphic components using generics and React’s `as` prop to define the underlying HTML element.

- **Example**:  
 - A polymorphic button component that accepts different HTML tags as children.

```tsx
type ButtonProps<T extends React.ElementType> = {
  as?: T;
  children: React.ReactNode;
};

function Button<T extends React.ElementType = 'button'>({
  as,
  children,
}: ButtonProps<T>) {
  const Component = as || 'button'; // Default to 'button'
  return <Component>{children}</Component>;
}

// Usage
<Button as="a" href="https://example.com">
  Go to example
</Button>
<Button>Default Button</Button>
```

---

#### 117. React TypeScript - Wrapping up

- **Concepts Covered**:  
 - Wrapping up the series with final thoughts on how to use TypeScript effectively with React.
 - Best practices for combining React and TypeScript, improving developer experience, and maintaining type safety.

- **Example**:  
 - A summary of best practices and tips for React and TypeScript integration.

---

### Key React Concepts Covered Throughout the Series:
- **Functional vs Class Components**: Understanding the differences and when to use one over the other.
- **JSX (JavaScript XML)**: Using JavaScript syntax to create React elements.
- **Props and State**: Managing component data and how to pass data between components.
- **Event Handling**: Handling events in React and binding methods.
- **React Hooks**: Essential hooks like `useState`, `useEffect`, `useContext`, and `useReducer`.
- **Component Lifecycle**: How React components live, mount, and update.
- **Styling in React**: Using CSS and libraries like `styled-components` for styling.
- **Performance Optimization**: Using techniques like `React.memo`, `useCallback`, and `useMemo`.
- **TypeScript in React**: How to use TypeScript with React, typing props, state, and hooks.
- **Context API and State Management**: Managing global state efficiently across your application.
- **Custom Hooks**: How to create and use custom hooks to encapsulate business logic.

---
