Here's a **Table of Contents** with clear navigation for the ReactJS Series, React Hooks Series, React Render Series, and React with TypeScript Series.

---

### **ReactJS Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 1     | ReactJS - Introduction                                                  | [ReactJS - Introduction](#1-reactjs---introduction)            |
| 2     | ReactJS - Hello World                                                   | [ReactJS - Hello World](#2-reactjs---hello-world)                        |
| 3     | ReactJS - Folder Structure                                              | [ReactJS - Folder Structure](#3-reactjs---folder-structure)              |
| 4     | ReactJS - Components                                                    | [ReactJS - Components](#4-reactjs---components)                          |
| 5     | ReactJS - Functional Components                                         | [ReactJS - Functional Components](#5-reactjs---functional-components)    |
| 6     | ReactJS - Class Components                                              | [ReactJS - Class Components](#6-reactjs---class-components)              |
| 7     | ReactJS - Hooks Update                                                  | [ReactJS - Hooks Update](#7-reactjs---hooks-update)                      |
| 8     | ReactJS - JSX                                                          | [ReactJS - JSX](#8-reactjs---jsx)                                        |
| 9     | ReactJS - Props                                                         | [ReactJS - Props](#9-reactjs---props)                                    |
| 10    | ReactJS - State                                                         | [ReactJS - State](#10-reactjs---state)                                    |
| 11    | ReactJS - setState                                                      | [ReactJS - setState](#11-reactjs---setstate)                              |
| 12    | ReactJS - Destructuring props and state                                  | [ReactJS - Destructuring props and state](#12-reactjs---destructuring-props-and-state) |
| 13    | ReactJS - Event Handling                                                | [ReactJS - Event Handling](#13-reactjs---event-handling)                  |
| 14    | ReactJS - Binding Event Handlers                                        | [ReactJS - Binding Event Handlers](#14-reactjs---binding-event-handlers)  |
| 15    | ReactJS - Methods as props                                              | [ReactJS - Methods as props](#15-reactjs---methods-as-props)               |
| 16    | ReactJS - Conditional Rendering                                         | [ReactJS - Conditional Rendering](#16-reactjs---conditional-rendering)    |
| 17    | ReactJS - List Rendering                                                | [ReactJS - List Rendering](#17-reactjs---list-rendering)                  |
| 18    | ReactJS - Lists and Keys                                                | [ReactJS - Lists and Keys](#18-reactjs---lists-and-keys)                  |
| 19    | ReactJS - Index as Key Anti-pattern                                     | [ReactJS - Index as Key Anti-pattern](#19-reactjs---index-as-key-anti-pattern) |
| 20    | ReactJS - Styling and CSS Basics                                        | [ReactJS - Styling and CSS Basics](#20-reactjs---styling-and-css-basics)  |
| 21    | ReactJS - Basics of Form Handling                                       | [ReactJS - Basics of Form Handling](#21-reactjs---basics-of-form-handling) |
| 22    | ReactJS - Component Lifecycle Methods                                   | [ReactJS - Component Lifecycle Methods](#22-reactjs---component-lifecycle-methods) |
| 23    | ReactJS - Component Mounting Lifecycle Methods                         | [ReactJS - Component Mounting Lifecycle Methods](#23-reactjs---component-mounting-lifecycle-methods) |
| 24    | ReactJS - Component Updating Lifecycle Methods                         | [ReactJS - Component Updating Lifecycle Methods](#24-reactjs---component-updating-lifecycle-methods) |
| 25    | ReactJS - Fragments                                                     | [ReactJS - Fragments](#25-reactjs---fragments)                            |
| 26    | ReactJS - Pure Components                                               | [ReactJS - Pure Components](#26-reactjs---pure-components)                |
| 27    | ReactJS - memo                                                          | [ReactJS - memo](#27-reactjs---memo)                                      |
| 28    | ReactJS - Refs                                                           | [ReactJS - Refs](#28-reactjs---refs)                                       |
| 29    | ReactJS - Refs with Class Components                                    | [ReactJS - Refs with Class Components](#29-reactjs---refs-with-class-components) |
| 30    | ReactJS - Forwarding Refs                                               | [ReactJS - Forwarding Refs](#30-reactjs---forwarding-refs)                |
| 31    | ReactJS - Portals                                                       | [ReactJS - Portals](#31-reactjs---portals)                                |
| 32    | ReactJS - Error Boundary                                                | [ReactJS - Error Boundary](#32-reactjs---error-boundary)                  |
| 33    | ReactJS - Higher Order Components (Part 1)                              | [ReactJS - Higher Order Components (Part 1)](#33-reactjs---higher-order-components-part-1) |
| 34    | ReactJS - Higher Order Components (Part 2)                              | [ReactJS - Higher Order Components (Part 2)](#34-reactjs---higher-order-components-part-2) |
| 35    | ReactJS - Higher Order Components (Part 3)                              | [ReactJS - Higher Order Components (Part 3)](#35-reactjs---higher-order-components-part-3) |
| 36    | ReactJS - Render Props (Part 1)                                         | [ReactJS - Render Props (Part 1)](#36-reactjs---render-props-part-1)       |
| 37    | ReactJS - Render Props (Part 2)                                         | [ReactJS - Render Props (Part 2)](#37-reactjs---render-props-part-2)       |
| 38    | ReactJS - Context (Part 1)                                              | [ReactJS - Context (Part 1)](#38-reactjs---context-part-1)                |
| 39    | ReactJS - Context (Part 2)                                              | [ReactJS - Context (Part 2)](#39-reactjs---context-part-2)                |
| 40    | ReactJS - Context (Part 3)                                              | [ReactJS - Context (Part 3)](#40-reactjs---context-part-3)                |
| 41    | ReactJS - HTTP and React                                                | [ReactJS - HTTP and React](#41-reactjs---http-and-react)                  |
| 42    | ReactJS - HTTP GET Request                                              | [ReactJS - HTTP GET Request](#42-reactjs---http-get-request)              |
| 43    | ReactJS - HTTP Post Request                                             | [ReactJS - HTTP Post Request](#43reactjs---http-post-request)            |

---

### **React Hooks Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 44    | React Hooks - Introduction                                               | [React Hooks - Introduction](#44-react-hooks---introduction)             |
| 45    | React Hooks - useState Hook                                              | [React Hooks - useState Hook](#45-react-hooks---usestate-hook)            |
| 46    | React Hooks - useState with previous state                              | [React Hooks - useState with previous state](#46-react-hooks---usestate-with-previous-state) |
| 47    | React Hooks - useState with object                                       | [React Hooks - useState with object](#47-react-hooks---usestate-with-object) |
| 48    | React Hooks - useState with array                                        | [React Hooks - useState with array](#48-react-hooks---usestate-with-array) |
| 49    | React Hooks - useEffect Hook                                             | [React Hooks - useEffect Hook](#49-react-hooks---useeffect-hook)          |
| 50    | React Hooks - useEffect after render                                    | [React Hooks - useEffect after render](#50-react-hooks---useeffect-after-render) |
| 51    | React Hooks - Conditionally run effects                                 | [React Hooks - Conditionally run effects](#501react-hooks---conditionally-run-effects) |
| 52    | React Hooks - Run effects only once                                     | [React Hooks - Run effects only once](#52-react-hooks---run-effects-only-once) |
| 53    | React Hooks - useEffect with cleanup                                    | [React Hooks - useEffect with cleanup](#53-react-hooks---useeffect-with-cleanup) |
| 54    | React Hooks - useEffect with incorrect dependency                       | [React Hooks - useEffect with incorrect dependency](#54-react-hooks---useeffect-with-incorrect-dependency) |
| 55    | React Hooks - Fetching data with useEffect Part 1                       | [React Hooks - Fetching data with useEffect Part 1](#55-react-hooks---fetching-data-with-useeffect-part-1) |
| 56    | React Hooks - Fetching data with useEffect Part 2                       | [React Hooks - Fetching data with useEffect Part 2](#56-react-hooks---fetching-data-with-useeffect-part-2) |
| 57    | React Hooks - Fetching data with useEffect Part 3                       | [React Hooks - Fetching data with useEffect Part 3](#57-react-hooks---fetching-data-with-useeffect-part-3) |
| 58    | React Hooks - useContext Hook Part 1                                     | [React Hooks - useContext Hook Part 1](#58-react-hooks---usecontext-hook-part-1) |
| 59    | React Hooks - useContext Hook Part 2                                     | [React Hooks - useContext Hook Part 2](#59-react-hooks---usecontext-hook-part-2) |
| 60    | React Hooks - useContext Hook Part 3                                     | [React Hooks - useContext Hook Part 3](#60-react-hooks---usecontext-hook-part-3) |
| 61    | React Hooks - useReducer Hook                                           | [React Hooks - useReducer Hook](#61-react-hooks---usereducer-hook)       |
| 62    | React Hooks - useReducer (simple state & action)                        | [React Hooks - useReducer (simple state & action)](#62-react-hooks---usereducer-simple-state-action) |
| 63    | React Hooks - useReducer (complex state & action)                       | [React Hooks - useReducer (complex state & action)](#63-react-hooks---usereducer-complex-state-action) |
| 64    | React Hooks - Multiple useReducers                                      | [React Hooks - Multiple useReducers](#64-react-hooks---multiple-usereducers) |
| 65    | React Hooks - useReducer with useContext                                | [React Hooks - useReducer with useContext](#65-react-hooks---usereducer-with-usecontext) |
| 66    | React Hooks - Fetching data with useReducer Part 1                       | [React Hooks - Fetching data with useReducer Part 1](#66-react-hooks---fetching-data-with-usereducer-part-1) |
| 67    | React Hooks - Fetching data with useReducer Part 2                       | [React Hooks - Fetching data with useReducer Part 2](#67-react-hooks---fetching-data-with-usereducer-part-2) |
| 68    | React Hooks - useState vs useReducer                                     | [React Hooks - useState vs useReducer](#68-react-hooks---usestate-vs-usereducer) |
| 69    | React Hooks - useCallback Hook                                           | [React Hooks - useCallback Hook](#69-react-hooks---usecallback-hook)     |
| 70    | React Hooks - useMemo Hook                                              | [React Hooks - useMemo Hook](#70-react-hooks---usememo-hook)             |
| 71    | React Hooks - useRef Hook Part 1                                         | [React Hooks - useRef Hook Part 1](#71-react-hooks---useref-hook-part-1) |
| 72    | React Hooks - useRef Hook Part 2                                         | [React Hooks - useRef Hook Part 2](#72-react-hooks---useref-hook-part-2) |
| 73    | React Hooks - Custom Hooks                                              | [React Hooks - Custom Hooks](#73-react-hooks---custom-hooks)            |
| 74    | React Hooks - useDocumentTitle Custom Hook                              | [React Hooks - useDocumentTitle Custom Hook](#74-react-hooks---usedocumenttitle-custom-hook) |
| 75    | React Hooks - useCounter Custom Hook                                    | [React Hooks - useCounter Custom Hook](#75-react-hooks---usecounter-custom-hook) |
| 76    | React Hooks - useInput Custom Hook                                      | [React Hooks - useInput Custom Hook](#76-react-hooks---useinput-custom-hook) |

---

### **React Render Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 77    | React Render - Introduction                                              | [React Render - Introduction](#77-react-render---introduction)          |
| 78    | React Render - Rendering                                                 | [React Render - Rendering](#78-react-render---rendering)                |
| 79    | React Render - useState                                                 | [React Render - useState](#79-react-render---usestate)                   |
| 80    | React Render - useReducer                                               | [React Render - useReducer](#80-react-render---usereducer)               |
| 81    | React Render - State Immutability                                       | [React Render - State Immutability](#81-react-render---state-immutability) |
| 82    | React Render - Parent and Child                                         | [React Render - Parent and Child](#82-react-render---parent-and-child)  |
| 83    | React Render - Same Element Reference                                   | [React Render - Same Element Reference](#83-react-render---same-element-reference) |
| 84    | React Render - React memo                                               | [React Render - React memo](#84-react-render---react-memo)               |
| 85    | React Render - Questions on Optimization                                | [React Render - Questions on Optimization](#85-react-render---questions-on-optimization) |
| 86    | React Render - Incorrect memo with children                             | [React Render - Incorrect memo with children](#86-react-render---incorrect-memo-with-children) |
| 87    | React Render - Incorrect memo with Impure Component                     | [React Render - Incorrect memo with Impure Component](#87-react-render---incorrect-memo-with-impure-component) |
| 88    | React Render - Incorrect memo with props Reference                      | [React Render - Incorrect memo with props Reference](#88-react-render---incorrect-memo-with-props-reference) |
| 89    | React Render - useMemo and useCallback                                  | [React Render - useMemo and useCallback](#89-react-render---usememo-and-usecallback) |
| 90    | React Render - Context                                                  | [React Render - Context](#90-react-render---context)                     |
| 91    | React Render - Context and memo                                         | [React Render - Context and memo](#91-react-render---context-and-memo)  |
| 92    | React Render - Context and Same Element Reference                       | [React Render - Context and Same Element Reference](#92-react-render---context-and-same-element-reference) |

---

### **React with TypeScript Series**

| **#** | **Topic**                                                              | **Link**                                                            |
|---|----------------------------|---------------------------|
| 93    | React TypeScript - Introduction                                          | [React TypeScript - Introduction](#93-react-typescript---introduction)   |
| 94    | React TypeScript - Getting Started                                      | [React TypeScript - Getting Started](#94-react-typescript---getting-started) |
| 95    | React TypeScript - Typing Props                                         | [React TypeScript - Typing Props](#95-react-typescript---typing-props)    |
| 96    | React TypeScript - Basic Props                                          | [React TypeScript - Basic Props](#96-react-typescript---basic-props)      |
| 97    | React TypeScript - Advanced Props                                       | [React TypeScript - Advanced Props](#97-react-typescript---advanced-props) |
| 98    | React TypeScript - Event Props                                          | [React TypeScript - Event Props](#98-react-typescript---event-props)      |
| 99    | React TypeScript - Style Props                                          | [React TypeScript - Style Props](#99-react-typescript---style-props)      |
| 100   | React TypeScript - Prop Types and Tips                                  | [React TypeScript - Prop Types and Tips](#100-react-typescript---prop-types-and-tips) |
| 101   | React TypeScript - useState Hook                                        | [React TypeScript - useState Hook](#101-react-typescript---usestate-hook) |
| 102   | React TypeScript - useState Future Value                                | [React TypeScript - useState Future Value](#102-react-typescript---usestate-future-value) |
| 103   | React TypeScript - useState Type Assertion                              | [React TypeScript - useState Type Assertion](#103-react-typescript---usestate-type-assertion) |
| 104   | React TypeScript - useReducer Hook                                      | [React TypeScript - useReducer Hook](#104-react-typescript---usereducer-hook) |
| 105   | React TypeScript - useReducer Strict Action Types                       | [React TypeScript - useReducer Strict Action Types](#105-react-typescript---usereducer-strict-action-types) |
| 106   | React TypeScript - useContext Hook                                      | [React TypeScript - useContext Hook](#106-react-typescript---usecontext-hook) |
| 107   | React TypeScript - useContext Future Value                              | [React TypeScript - useContext Future Value](#107-react-typescript---usecontext-future-value) |
| 108   | React TypeScript - useRef Hook                                          | [React TypeScript - useRef Hook](#108-react-typescript---useref-hook)     |
| 109   | React TypeScript - Class Component                                      | [React TypeScript - Class Component](#109-react-typescript---class-component) |
| 110   | React TypeScript - Component Prop                                       | [React TypeScript - Component Prop](#110-react-typescript---component-prop) |
| 111   | React TypeScript - Generic Props                                        | [React TypeScript - Generic Props](#111-react-typescript---generic-props)  |
| 112   | React TypeScript - Restricting Props                                    | [React TypeScript - Restricting Props](#112-react-typescript---restricting-props) |
| 113   | React TypeScript - Template Literals and Exclude                        | [React TypeScript - Template Literals and Exclude](#113-react-typescript---template-literals-and-exclude) |
| 114   | React TypeScript - Wrapping HTML Elements                               | [React TypeScript - Wrapping HTML Elements](#114-react-typescript---wrapping-html-elements) |
| 115   | React TypeScript - Extracting a Components Prop Types                   | [React TypeScript - Extracting a Components Prop Types](#115-react-typescript---extracting-a-components-prop-types) |
| 116   | React TypeScript - Polymorphic Components                               | [React TypeScript - Polymorphic Components](#116-react-typescript---polymorphic-components) |
| 117   | React TypeScript - Wrapping up                                          | [React TypeScript - Wrapping up](#117-react-typescript---wrapping-up)      |

---

### 1. ReactJS - Introduction

- **Concepts Covered**:
 - ### Introduction to React

**React** is a powerful JavaScript library for building user interfaces, developed and maintained by Facebook. It enables developers to create dynamic, efficient, and interactive user interfaces (UIs) by breaking down complex UIs into smaller, reusable components. React is primarily used for building single-page applications (SPAs) where the user interaction happens without requiring page reloads.

React has grown in popularity due to its simplicity, flexibility, and high performance. It's used by major companies like Facebook, Instagram, Netflix, Airbnb, and many others. React's virtual DOM (Document Object Model) allows for fast updates and rendering of user interfaces, making it an excellent choice for high-performance web applications.

 - ### Why use React?

There are several reasons why developers and teams choose React for building modern web applications:

1. **Component-Based Architecture**:
   - React promotes a **component-based architecture**, which means the user interface is broken down into smaller, independent, reusable components. Each component can manage its own state and render its own part of the UI.
   - This leads to better **modularity**, **reusability**, and **maintainability** of code.
   
2. **Declarative Syntax**:
   - React uses a declarative programming style, meaning developers describe **what the UI should look like** based on the current state of the application, rather than specifying the steps needed to update the UI.
   - This makes React code easier to understand, less error-prone, and more predictable.

3. **Virtual DOM for Performance**:
   - React uses a **virtual DOM**, which is a lightweight copy of the actual DOM. When the state of a component changes, React updates the virtual DOM first, compares it with the previous version, and only makes the necessary changes to the actual DOM. This improves performance by minimizing expensive DOM manipulation.
   
4. **Large Ecosystem**:
   - React has a thriving ecosystem of libraries and tools that complement it, including **React Router** for routing, **Redux** for state management, and **Next.js** for server-side rendering. This helps streamline the development process and integrate additional features.

5. **Strong Community Support**:
   - React has a massive community, offering a wealth of tutorials, third-party libraries, and open-source tools. As one of the most widely-used JavaScript libraries, React has strong backing and frequent updates from both Facebook and the open-source community.

6. **Cross-Platform Development (React Native)**:
   - With **React Native**, developers can use the same React concepts to build mobile applications for **iOS** and **Android**, effectively allowing for code reuse across platforms and reducing development time and cost.
     
 - ### Core features of React (Declarative, Component-based, Learn once, write anywhere, etc.)

React’s core features set it apart from other JavaScript libraries and frameworks. These features make it easy to build modern, interactive UIs that are highly performant, maintainable, and scalable.

#### 1. **Declarative UI**:
   - React allows developers to describe the user interface in a **declarative** way, focusing on **what** the UI should look like based on the state, rather than **how** to update the UI. This makes the UI more predictable and easier to debug.
   - **Example**: Instead of directly manipulating DOM elements, you just define components and their states, and React ensures the UI stays in sync with the data.

   **Example Code**:
   ```js
   const MyComponent = () => {
     const [count, setCount] = useState(0);
     
     return (
       <div>
         <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}>Click me</button>
       </div>
     );
   }
   ```

#### 2. **Component-Based Architecture**:
   - In React, everything is a component. A component can represent a **button**, a **form**, or even an entire **page**. These components are **reusable**, **isolated**, and can be composed to build more complex UIs.
   - Components are either **stateful** (managing data) or **stateless** (rendering based on props), and React encourages developers to break the UI into smaller, modular pieces for better maintainability.

   **Example Code**:
   ```js
   const WelcomeMessage = () => {
     return <h1>Welcome to React!</h1>;
   };
   const App = () => {
     return <WelcomeMessage />;
   };
   ```

#### 3. **Learn Once, Write Anywhere**:
   - One of the main selling points of React is its ability to allow developers to **learn once** and **apply their knowledge everywhere**. You can build:
     - **Web applications** with React for the frontend.
     - **Mobile apps** using **React Native** for both iOS and Android.
     - **Desktop applications** with frameworks like **Electron**.
   - React provides a unified model of development, meaning developers can use the same concepts across various platforms, simplifying the learning curve.

#### 4. **JSX (JavaScript XML)**:
   - JSX is a syntax extension for JavaScript that allows HTML to be written within JavaScript. It looks like regular HTML, but it's ultimately transformed into JavaScript.
   - JSX makes it easy to write and visualize the component structure within React code.

   **Example Code**:
   ```js
   const MyComponent = () => {
     return <h1>Hello, World!</h1>;
   };
   ```
   Under the hood, JSX is converted into `React.createElement()` calls, but using JSX syntax makes it much more readable and intuitive.

#### 5. **Unidirectional Data Flow**:
   - React follows a **unidirectional data flow**, meaning that data flows from **parent** components to **child** components via **props**. This makes it easier to track how data is being passed and modified throughout the application.
   - Changes in the state of a component will trigger re-rendering, but the flow of data remains predictable and manageable.

   **Example Code**:
   ```js
   const ParentComponent = () => {
     const [data, setData] = useState('Hello');
     return <ChildComponent message={data} />;
   };

   const ChildComponent = ({ message }) => {
     return <h1>{message}</h1>;
   };
   ```

#### 6. **Virtual DOM**:
   - React uses a **virtual DOM**, which is a lightweight in-memory representation of the actual DOM. When the state of a component changes, React first updates the virtual DOM and compares it with the previous version of the virtual DOM. It then calculates the minimal set of changes required to update the actual DOM, which improves performance and responsiveness.

#### 7. **React Hooks**:
   - React introduced **Hooks** in version 16.8, which allow functional components to manage state and side effects. With hooks like `useState`, `useEffect`, and `useContext`, developers can add functionality to components without needing to write class-based components.
   - This leads to cleaner, more readable code and makes React more accessible to developers familiar with functional programming.

   **Example Code**:
   ```js
   const Counter = () => {
     const [count, setCount] = useState(0);
     
     useEffect(() => {
       document.title = `You clicked ${count} times`;
     }, [count]);

     return (
       <div>
         <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}>Click me</button>
       </div>
     );
   };
   ```

#### 8. **Lifecycle Methods (Class Components)**:
   - In class components, React provides **lifecycle methods** like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` to handle side effects like API calls, timers, or cleanup actions.
   - While newer versions of React favor **functional components** and hooks, lifecycle methods are still an important feature for class components.
    
- **Example**:
  React is a declarative, efficient, and flexible JavaScript library for building user interfaces. It lets you build complex UIs from small and isolated pieces of code called “components.”

```jsx
// Simple React component
import React from 'react';

const App = () => {
  return (
    <div>
      <h1>Hello, World! Welcome to React!</h1>
    </div>
  );
};

export default App;
```
---

### **Conclusion**

React's declarative approach, component-based structure, and efficient virtual DOM make it an excellent choice for building modern, interactive user interfaces. Whether you're working on a web, mobile, or desktop app, React provides a consistent and flexible approach to building user interfaces. The ability to break down UIs into reusable components and manage state and side effects with hooks makes React an ideal tool for developing scalable, maintainable applications.

---

### 2. ReactJS - Hello World

- **Concepts Covered**:
 - How to set up a simple React app
 - Running React in the browser using `create-react-app`

- **Example**:
  Here’s a simple "Hello World" app. You can use `create-react-app` to quickly start a React app.

```bash
npx create-react-app hello-world
cd hello-world
npm start
```

In `src/App.js`:

```jsx
import React from 'react';

function App() {
  return (
    <div className="App">
      <h1>Hello, World!</h1>
    </div>
  );
}

export default App;
```

---

### 3. ReactJS - Folder Structure

- **Concepts Covered**:
 - Typical folder structure in a React project.
 - How to organize components, assets, and config files.

- **Example**:
  Here’s an ideal folder structure for a React project:

```
/src
  /components
    Header.js
    Footer.js
  /assets
    logo.png
  /styles
    App.css
  App.js
  index.js
```

```jsx
// Example in App.js
import React from 'react';
import './styles/App.css';  // Importing styles

function App() {
  return <div className="App">Hello, World!</div>;
}

export default App;
```

---

### 4. ReactJS - Components

- **Concepts Covered**:
 - Functional vs. Class components in React.
 - Creating reusable components.

- **Example**:
  **Functional Component:**

```jsx
// Functional Component
const Greeting = () => {
  return <h1>Hello, Welcome to React!</h1>;
};
```

**Class Component:**

```jsx
// Class Component
import React, { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, Welcome to React!</h1>;
  }
}

export default Greeting;
```

---

### 5. ReactJS - Functional Components

- **Concepts Covered**:
 - Writing functional components using JSX syntax.

- **Example**:
  Here’s a stateless functional component that displays a greeting:

```jsx
const Greeting = (props) => {
  return <h1>{props.message}</h1>;
};

export default Greeting;
```

You can use it in the main `App` component:

```jsx
import React from 'react';
import Greeting from './Greeting';

const App = () => {
  return (
    <div>
      <Greeting message="Hello, React!" />
    </div>
  );
};

export default App;
```

---

### 6. ReactJS - Class Components

- **Concepts Covered**:
 - Creating class-based components.
 - Lifecycle methods in class components.

- **Example**:
  Class components come with lifecycle methods such as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = {
      count: 0,
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

---

### 7. ReactJS - Hooks Update

- **Concepts Covered**:
 - Introduction to React Hooks.
 - Using `useState` and `useEffect`.

- **Example**:
  Using the `useState` hook for managing state in a functional component:

```jsx
import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default Counter;
```

---

### 8. ReactJS - JSX

- **Concepts Covered**:
 - Understanding JSX and how it’s compiled to React’s `createElement`.

- **Example**:
  JSX is a syntax extension for JavaScript that looks similar to HTML. It allows us to write elements and components in a declarative way.

```jsx
const element = <h1>Hello, World!</h1>;
```

Behind the scenes, JSX is converted to JavaScript code using `React.createElement()`:

```jsx
const element = React.createElement('h1', null, 'Hello, World!');
```

---

### 9. ReactJS - Props

- **Concepts Covered**:
 - Props in React components.
 - Passing data from parent to child components.

- **Example**:
  Here’s how you can pass props to a child component:

```jsx
const Greeting = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

const App = () => {
  return <Greeting name="John" />;
};
```

In React, passing data from a parent component to a child component is done via **props**. The parent component passes the data as props to the child, which the child can then use within its own render function.

Here's a simple example to demonstrate how data flows from parent to child.

### Example of Passing Data from Parent to Child

#### 1. **Parent Component:**

The parent component defines the data it wants to send to the child and passes it as a prop.

```jsx
import React from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const parentData = "Hello from Parent!"; // This is the data to pass to the child

  return (
    <div>
      <h1>Parent Component</h1>
      <ChildComponent dataFromParent={parentData} />
    </div>
  );
}

export default ParentComponent;
```

#### 2. **Child Component:**

The child component receives the prop and uses it within its own render method.

```jsx
import React from 'react';

function ChildComponent({ dataFromParent }) {
  return (
    <div>
      <h2>Child Component</h2>
      <p>{dataFromParent}</p> {/* Display the data received from the parent */}
    </div>
  );
}

export default ChildComponent;
```

### Explanation:

1. **Parent Component**:
   - The parent defines a piece of state or variable, in this case `parentData`.
   - This data is passed to the child component as a prop named `dataFromParent`.

2. **Child Component**:
   - The child component receives `dataFromParent` as a prop.
   - The child can use this data within its render method (in the example, it displays it inside a `<p>` tag).

### Key Concepts:
- **Props**: Props are the mechanism by which data is passed from a parent component to a child component. In the example above, `dataFromParent` is a prop that the parent provides to the child.
- **Read-Only**: Props are read-only. The child cannot modify the props it receives directly. If the child needs to modify data, it would typically use an event handler to notify the parent, who can then update the state and pass new props down to the child.

### Example with Dynamic Data (State in Parent):

You can also pass dynamic data (state) from parent to child. Here's an example where the parent component has state that it passes to the child.

```jsx
import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const [parentData, setParentData] = useState("Initial data from parent");

  return (
    <div>
      <h1>Parent Component</h1>
      <button onClick={() => setParentData("Updated data from parent")}>
        Update Data
      </button>
      <ChildComponent dataFromParent={parentData} />
    </div>
  );
}

export default ParentComponent;
```

In this case:
- The `parentData` is stored in the parent's state using `useState`.
- The parent can update this state (e.g., via a button click), and the updated data will automatically be passed down to the child as a prop.

### Key Points:
- **Props are read-only**: The child can use the data but cannot directly change it. If the child needs to change the data, it must communicate this to the parent, which can then modify its state and pass the updated data back to the child.
- **One-way data flow**: React follows a one-way data flow, meaning data is passed down from parent to child but not the other way around.

This approach is the fundamental way React handles communication from parent to child components.

In React, passing data from a child component to a parent component is done through **callback functions** (also known as event handlers) that are passed down as props to the child component. The child component can then invoke the callback function, which triggers an update in the parent component.

### Example of Passing Data from Child to Parent

Let's say we have a parent component that wants to receive some data from its child component.

#### 1. **Parent Component:**

The parent component defines a function to handle the data and then passes it to the child as a prop.

```jsx
import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
  const [childData, setChildData] = useState("");

  // Callback function to handle data from the child
  const handleDataFromChild = (data) => {
    setChildData(data);  // Update state with data received from child
  };

  return (
    <div>
      <h1>Data from Child: {childData}</h1>
      <ChildComponent onSendData={handleDataFromChild} />
    </div>
  );
}

export default ParentComponent;
```

#### 2. **Child Component:**

The child component receives the callback function via props and calls it when it wants to send data back to the parent.

```jsx
import React, { useState } from 'react';

function ChildComponent({ onSendData }) {
  const [inputData, setInputData] = useState("");

  const handleInputChange = (e) => {
    setInputData(e.target.value);
  };

  const sendDataToParent = () => {
    onSendData(inputData);  // Call the parent's callback function with the input data
  };

  return (
    <div>
      <input 
        type="text" 
        value={inputData} 
        onChange={handleInputChange} 
        placeholder="Enter some data"
      />
      <button onClick={sendDataToParent}>Send Data to Parent</button>
    </div>
  );
}

export default ChildComponent;
```

### Explanation:

1. **Parent Component**:
   - The parent defines a function `handleDataFromChild` to update its state with data from the child.
   - It passes this function as a prop to the child, named `onSendData`.

2. **Child Component**:
   - The child receives the `onSendData` prop and uses it to send data to the parent.
   - When the user types something in the input field and clicks the "Send Data to Parent" button, it calls `onSendData(inputData)` with the current value of the input.

### Key Concepts:
- **Callback Prop**: The parent passes a function down to the child. The child invokes this function when it needs to send data back up to the parent.
- **State**: The parent typically holds the state that is updated when data is received from the child.

This pattern allows the parent component to control the flow of data while letting the child component trigger changes in the parent's state.

---

### 10. ReactJS - State

- **Concepts Covered**:
 - Introduction to state in React and how to manage it.

- **Example**:
  A controlled form component that updates state based on user input:

```jsx
import React, { useState } from 'react';

const Form = () => {
  const [input, setInput] = useState('');

  const handleChange = (e) => setInput(e.target.value);

  return (
    <form>
      <input type="text" value={input} onChange={handleChange} />
      <p>{input}</p>
    </form>
  );
};

export default Form;
```

---

### 11. ReactJS - setState

- **Concepts Covered**:
 - Using `setState` in class components to update the state.

- **Example**:
  Here’s how you use `setState` to update state in class components:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

---

### 12. ReactJS - Destructuring props and state

- **Concepts Covered**:
 - Destructuring props and state to improve code readability.

- **Example**:
  Here’s how destructuring works in functional components:

```jsx
const Greeting = ({ name, age }) => {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>You are {age} years old.</p>
    </div>
  );
};
```

In this example, `name` and `age` are destructured directly from `props`.

---

### 13. ReactJS - Event Handling

- **Concepts Covered**:
 - Handling events like `onClick`, `onSubmit` in React.

- **Example**:
  Handling a click event in React:

```jsx
import React, { useState } from 'react';

const ButtonClick = () => {
  const [clicked, setClicked] = useState(false);

  const handleClick = () => setClicked(true);

  return (
    <div>
      <button onClick={handleClick}>Click Me!</button>
      {clicked && <p>You clicked the button!</p>}
    </div>
  );
};

export default ButtonClick;
```

---


### 14. ReactJS - Binding Event Handlers

- **Concepts Covered**:
  - Binding event handlers in class components.
  - How to use `this` in event handler methods.

- **Example**:
  In class components, methods need to be explicitly bound to the component instance using `.bind()`. Here’s an example:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor() {
    super();
    this.state = { count: 0 };
    // Binding the method to the component instance
    this.increment = this.increment.bind(this);
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

Alternatively, binding can also be done using an arrow function:

```jsx
<button onClick={() => this.increment()}>Increment</button>
```

---

### 15. ReactJS - Methods as Props

- **Concepts Covered**:
  - Passing methods as props from parent to child components.

- **Example**:
  Here, we pass a method from the parent (`App`) to the child (`ChildComponent`):

```jsx
// Parent Component
const App = () => {
  const handleClick = () => {
    alert("Button clicked!");
  };

  return <ChildComponent onClick={handleClick} />;
};

// Child Component
const ChildComponent = ({ onClick }) => {
  return <button onClick={onClick}>Click Me</button>;
};

export default App;
```

---

### 16. ReactJS - Conditional Rendering

- **Concepts Covered**:
  - Conditionally rendering components using JavaScript expressions.

- **Example**:
  Rendering content based on a condition, such as user authentication:

```jsx
import React, { useState } from 'react';

const App = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  return (
    <div>
      {isAuthenticated ? (
        <h1>Welcome back, User!</h1>
      ) : (
        <button onClick={() => setIsAuthenticated(true)}>Login</button>
      )}
    </div>
  );
};

export default App;
```

---

### 17. ReactJS - 17 - List Rendering

- **Concepts Covered**:
  - Rendering lists in React using `.map()`.

- **Example**:
  Displaying a list of items dynamically:

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
};

export default List;
```

---

### 18. ReactJS - Lists and Keys

- **Concepts Covered**:
  - Using `key` prop when rendering lists to optimize performance and ensure proper re-rendering.

- **Example**:
  When rendering dynamic lists, `key` helps React identify which items have changed, been added, or removed:

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item) => (
        <li key={item}>{item}</li> // Using a unique value for 'key'
      ))}
    </ul>
  );
};

export default List;
```

---

### 19. ReactJS - Index as Key Anti-pattern

- **Concepts Covered**:
  - Why using the index as the key can be problematic, especially with dynamic lists.

- **Example**:
  **Bad Practice:**

```jsx
const items = ['Apple', 'Banana', 'Orange'];

const List = () => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li> // Using index as key
      ))}
    </ul>
  );
};
```

Using `index` as a key might cause issues with reordering elements. A better approach is to use unique values as keys:

```jsx
const items = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Orange' },
];

const List = () => {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li> // Using unique 'id' as key
      ))}
    </ul>
  );
};
```

---

### 20. ReactJS - Styling and CSS Basics

- **Concepts Covered**:
  - Different ways to style React components (inline styles, external CSS, CSS modules).

- **Example**:
  - **Inline Styles**:

```jsx
const App = () => {
  const divStyle = {
    color: 'blue',
    backgroundColor: 'lightgray',
  };

  return <div style={divStyle}>Styled Div</div>;
};

export default App;
```

  - **External CSS**:

```jsx
// App.css
.App {
  color: blue;
  background-color: lightgray;
}

// App.js
import './App.css';

const App = () => {
  return <div className="App">Styled Div</div>;
};

export default App;
```

  - **CSS Modules**:

```jsx
// App.module.css
.container {
  color: blue;
  background-color: lightgray;
}

// App.js
import styles from './App.module.css';

const App = () => {
  return <div className={styles.container}>Styled Div</div>;
};

export default App;
```

---

### 21. ReactJS - Basics of Form Handling

- **Concepts Covered**:
  - Handling forms in React with controlled components.

- **Example**:
  A simple controlled form:

```jsx
import React, { useState } from 'react';

const Form = () => {
  const [input, setInput] = useState('');

  const handleChange = (e) => {
    setInput(e.target.value);
  };

  return (
    <form>
      <input type="text" value={input} onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
};

export default Form;
```

---

### 22. ReactJS - Component Lifecycle Methods

- **Concepts Covered**:
  - Lifecycle methods such as `componentDidMount` and `componentDidUpdate` in class components.

- **Example**:
  Using `componentDidMount()` to fetch data:

```jsx
import React, { Component } from 'react';

class DataFetcher extends Component {
  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
  }

  render() {
    return <div>{this.state ? this.state.data : 'Loading...'}</div>;
  }
}

export default DataFetcher;
```

---

### 23. ReactJS - Component Mounting Lifecycle Methods

- **Concepts Covered**:
  - Mounting phase lifecycle methods: `constructor()`, `render()`, `componentDidMount()`.

- **Example**:
  Using `componentDidMount` to fetch data after the initial render:

```jsx
class App extends React.Component {
  constructor() {
    super();
    this.state = { data: null };
  }

  componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
  }

  render() {
    return <div>{this.state.data ? this.state.data : 'Loading...'}</div>;
  }
}

export default App;
```

---

### 24. ReactJS - Component Updating Lifecycle Methods

- **Concepts Covered**:
  - Lifecycle methods for handling updates: `shouldComponentUpdate`, `componentDidUpdate`.

- **Example**:
  Using `componentDidUpdate` to react to prop changes:

```jsx
import React, { Component } from 'react';

class App extends Component {
  componentDidUpdate(prevProps) {
    if (this.props.value !== prevProps.value) {
      console.log('Value updated:', this.props.value);
    }
  }

  render() {
    return <div>{this.props.value}</div>;
  }
}

export default App;
```

In React, the **component update lifecycle** refers to the sequence of methods that React calls when a component’s state or props change. Understanding these methods is key for managing side effects, performance optimizations, and updating the UI efficiently.

Here’s a breakdown of the main lifecycle methods that occur during the **update phase** (when a component’s state or props change) in a **class component**:

---

### 1. **`static getDerivedStateFromProps(nextProps, nextState)`**
   - **Purpose**: This method is called before every render, both when the component is created and when it is updated. It allows you to update the state based on changes to props.
   - **Signature**:
     ```js
     static getDerivedStateFromProps(nextProps, nextState)
     ```
   - **Parameters**:
     - `nextProps`: The next set of props that the component will receive.
     - `nextState`: The current state at the time of the update.
   - **Return value**: You should return an object that will be merged into the state, or `null` if no state updates are necessary.
   - **When it's called**: Called before every render, triggered by changes to state or props.
   
   **Example**:
   ```js
   static getDerivedStateFromProps(nextProps, nextState) {
     if (nextProps.someValue !== nextState.someValue) {
       return {
         someValue: nextProps.someValue
       };
     }
     return null;  // No state change
   }
   ```

### 2. **`shouldComponentUpdate(nextProps, nextState)`**
   - **Purpose**: This method allows you to optimize performance by preventing unnecessary re-renders. If it returns `false`, React will skip the render.
   - **Signature**:
     ```js
     shouldComponentUpdate(nextProps, nextState)
     ```
   - **Parameters**:
     - `nextProps`: The next props that will be passed to the component.
     - `nextState`: The next state that the component will have after the update.
   - **Return value**: Boolean (`true` or `false`). Return `true` to allow the render to proceed, `false` to skip it.
   - **When it's called**: Called before `render` when props or state change.
   
   **Example**:
   ```js
   shouldComponentUpdate(nextProps, nextState) {
     // Only re-render if the prop "count" has changed
     return nextProps.count !== this.props.count;
   }
   ```

### 3. **`render()`**
   - **Purpose**: This is the core method that React calls to render the component to the DOM. It should return JSX or `null` if nothing should be rendered.
   - **Signature**:
     ```js
     render()
     ```
   - **Return value**: JSX (or `null`).
   - **When it's called**: Called during every update (whenever `shouldComponentUpdate` returns `true` or is not implemented).

   **Example**:
   ```js
   render() {
     return <div>{this.props.someValue}</div>;
   }
   ```

### 4. **`getSnapshotBeforeUpdate(prevProps, prevState)`**
   - **Purpose**: This method allows you to capture some information (like scroll position) from the DOM before it is potentially changed by the update. The value returned by this method will be passed as the third argument to `componentDidUpdate`.
   - **Signature**:
     ```js
     getSnapshotBeforeUpdate(prevProps, prevState)
     ```
   - **Parameters**:
     - `prevProps`: The previous props of the component.
     - `prevState`: The previous state of the component.
   - **Return value**: Any value (such as scroll position) you want to capture before the DOM is updated. This value is passed to `componentDidUpdate`.
   - **When it's called**: Called right before the DOM is updated, after `render()` but before `componentDidUpdate`.

   **Example**:
   ```js
   getSnapshotBeforeUpdate(prevProps, prevState) {
     if (prevState.scrollPosition !== this.state.scrollPosition) {
       return this.refs.scrollContainer.scrollTop;
     }
     return null;
   }
   ```

### 5. **`componentDidUpdate(prevProps, prevState, snapshot)`**
   - **Purpose**: This method is called after the component has been re-rendered and the updates have been flushed to the DOM. It's useful for performing side effects or interacting with the DOM.
   - **Signature**:
     ```js
     componentDidUpdate(prevProps, prevState, snapshot)
     ```
   - **Parameters**:
     - `prevProps`: The previous props of the component.
     - `prevState`: The previous state of the component.
     - `snapshot`: The value returned by `getSnapshotBeforeUpdate`.
   - **When it's called**: Called after the render, when the DOM has been updated, and it is useful for handling any post-update operations (e.g., data fetching, animations, etc.).
   
   **Example**:
   ```js
   componentDidUpdate(prevProps, prevState, snapshot) {
     if (prevState.someValue !== this.state.someValue) {
       console.log('State changed, do something');
     }
   }
   ```

---

### 6. **`componentWillUnmount()`**
   - **Purpose**: This method is called just before the component is removed from the DOM. It’s used for cleanup tasks such as cancelling network requests, clearing timers, or removing event listeners.
   - **Signature**:
     ```js
     componentWillUnmount()
     ```
   - **When it's called**: Called when the component is about to be unmounted and destroyed.

   **Example**:
   ```js
   componentWillUnmount() {
     clearInterval(this.timer);
   }
   ```

---

### Summary of Component Update Lifecycle:
1. **`getDerivedStateFromProps`** (before render) — updates state based on props.
2. **`shouldComponentUpdate`** (before render) — decides whether to re-render.
3. **`render`** (during the update) — renders JSX.
4. **`getSnapshotBeforeUpdate`** (before DOM changes) — captures DOM state before updates.
5. **`componentDidUpdate`** (after render) — performs side effects after the update.
6. **`componentWillUnmount`** (before unmount) — cleans up before the component is removed.

### Functional Components (Hooks):
In modern React with **functional components**, lifecycle methods are replaced with **Hooks** (e.g., `useEffect` for managing side effects). For example, `componentDidUpdate` can be replaced by `useEffect`, and `shouldComponentUpdate` can be optimized with `React.memo`.

#### Example (Functional Component using `useEffect`):
```js
import React, { useState, useEffect } from 'react';

function MyComponent(props) {
  const [someValue, setSomeValue] = useState(props.someValue);

  useEffect(() => {
    // Similar to componentDidUpdate
    console.log('Component updated');
  }, [someValue]); // Runs when `someValue` changes

  return <div>{someValue}</div>;
}
```

If you’re working with **class components**, the methods above are crucial for understanding how React updates and manages your components. If you're using **functional components** with hooks, the approach is a bit different, but the core concepts are still applicable!

---

### 25. ReactJS - Fragments

- **Concepts Covered**:
  - Using `React.Fragment` to group elements without adding extra DOM nodes.

- **Example**:
  Wrapping multiple elements without introducing an additional parent node:

```jsx
const FragmentExample = () => (
  <React.Fragment>
    <h1>Title</h1>
    <p>Content</p>
  </React.Fragment>
);

export default FragmentExample;
```

---

### 26. ReactJS - Pure Components

- **Concepts Covered**:
 - Using `React.PureComponent` to optimize performance by preventing unnecessary re-renders.
 - `PureComponent` performs a shallow comparison of props and state to determine whether the component needs to re-render.

- **Example**:
  If a component's state or props haven't changed, it won't re-render, improving performance.

```jsx
import React, { PureComponent } from 'react';

class Counter extends PureComponent {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    console.log('Rendered');
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```
`PureComponent` ensures the component only re-renders when `props` or `state` change.

---

### 27. ReactJS - memo

- **Concepts Covered**:
 - `React.memo` for functional component optimization by memoizing the component and preventing unnecessary re-renders when props haven't changed.

- **Example**:
  Wrapping a functional component with `React.memo()` to optimize rendering:

```jsx
const Counter = React.memo(({ count, increment }) => {
  console.log('Rendered');
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
});

export default Counter;
```

`React.memo` is similar to `PureComponent` but for functional components.

---

### 28. ReactJS - Refs

- **Concepts Covered**:
 - Using `refs` to interact directly with DOM elements or React components.
 - `refs` are useful for tasks like focusing an input field, measuring elements, or triggering animations.

- **Example**:
  Focusing an input field using a ref:

```jsx
import React, { useRef } from 'react';

const FocusInput = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default FocusInput;
```

Here, `useRef` is used to create a reference to the input element, which we can then focus using `inputRef.current.focus()`.

---

### ReactJS - Refs with Class Components

- **Concepts Covered**:
 - Handling `refs` in class components.

- **Example**:
  Using `refs` in a class component to access a DOM element:

```jsx
import React, { Component } from 'react';

class FocusInput extends Component {
  constructor() {
    super();
    this.inputRef = React.createRef();
  }

  handleFocus = () => {
    this.inputRef.current.focus();
  };

  render() {
    return (
      <div>
        <input ref={this.inputRef} type="text" />
        <button onClick={this.handleFocus}>Focus Input</button>
      </div>
    );
  }
}

export default FocusInput;
```

In class components, `React.createRef()` is used to create refs, which are then accessed via `this.inputRef.current`.

---

### 30. ReactJS - Forwarding Refs

- **Concepts Covered**:
 - Forwarding refs to child components using `React.forwardRef()`.
 - This is useful when you need to pass refs through higher-order components or functional components.

- **Example**:
  Forwarding refs to a child component:

```jsx
import React, { forwardRef } from 'react';

const Input = forwardRef((props, ref) => (
  <input ref={ref} {...props} />
));

const Parent = () => {
  const inputRef = React.useRef(null);

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <Input ref={inputRef} />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Parent;
```

Here, `React.forwardRef` allows the `Input` component to accept a `ref` passed from the parent component.

---

### 31. ReactJS - Portals

- **Concepts Covered**:
 - Using `ReactDOM.createPortal` to render a component outside its parent DOM hierarchy, useful for modals, tooltips, etc.

- **Example**:
  Creating a modal component with portals:

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Modal = ({ children }) => {
  return ReactDOM.createPortal(
    <div className="modal">
      <div className="modal-content">{children}</div>
    </div>,
    document.getElementById('modal-root') // Rendering outside parent DOM
  );
};

export default Modal;
```

Here, the modal is rendered outside the main React component tree, allowing it to overlay on top of other content.

---

### 32. ReactJS - Error Boundary

- **Concepts Covered**:
 - Using Error Boundaries to catch JavaScript errors in components and display a fallback UI.

- **Example**:
  Implementing an Error Boundary to handle errors gracefully:

```jsx
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error occurred:", error);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

const BuggyComponent = () => {
  throw new Error('Oops!');
};

const App = () => (
  <ErrorBoundary>
    <BuggyComponent />
  </ErrorBoundary>
);

export default App;
```

`componentDidCatch` catches the error, while `getDerivedStateFromError` updates the UI to show a fallback message.

---

### 33. ReactJS - Higher Order Components (Part 1)

- **Concepts Covered**:
 - Introduction to Higher-Order Components (HOCs), which are functions that take a component and return a new component with enhanced functionality.

- **Example**:
  Creating a `withLoader` HOC that adds loading functionality to a component:

```jsx
import React, { useState, useEffect } from 'react';

const withLoader = (WrappedComponent) => {
  return (props) => {
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      setTimeout(() => setLoading(false), 2000);
    }, []);

    if (loading) {
      return <div>Loading...</div>;
    }

    return <WrappedComponent {...props} />;
  };
};

const UserComponent = () => <div>User Data</div>;

const UserWithLoader = withLoader(UserComponent);

export default UserWithLoader;
```

`withLoader` enhances `UserComponent` by showing a loading indicator before rendering the user data.

---

### 34. ReactJS - Higher Order Components (Part 2)

- **Concepts Covered**:
 - More examples of HOCs, such as adding authentication checks to components.

- **Example**:
  Creating an `withAuth` HOC that ensures the user is authenticated:

```jsx
const withAuth = (WrappedComponent) => {
  return (props) => {
    const isAuthenticated = false; // Replace with actual auth check

    if (!isAuthenticated) {
      return <div>Please log in to access this page.</div>;
    }

    return <WrappedComponent {...props} />;
  };
};

const Dashboard = () => <div>Dashboard</div>;

const ProtectedDashboard = withAuth(Dashboard);

export default ProtectedDashboard;
```

`withAuth` wraps `Dashboard` and ensures the user is logged in before rendering.

---

### 35. ReactJS - Higher Order Components (Part 3)

- **Concepts Covered**:
 - Handling more complex scenarios with HOCs, like error handling.

- **Example**:
  Creating a `withErrorHandler` HOC to handle errors in the wrapped component:

```jsx
import React from 'react';

const withErrorHandler = (WrappedComponent) => {
  return (props) => {
    try {
      return <WrappedComponent {...props} />;
    } catch (error) {
      return <div>Error occurred: {error.message}</div>;
    }
  };
};

const SomeComponent = () => {
  throw new Error('An error occurred!');
};

const SafeComponent = withErrorHandler(SomeComponent);

export default SafeComponent;
```

This HOC catches errors in `SomeComponent` and displays an error message instead of crashing the app.

---

### 36. ReactJS - Render Props (Part 1)

- **Concepts Covered**:
 - Introduction to the Render Props pattern, where a component receives a function as a prop and calls it to render dynamic content.

- **Example**:
  Creating a `MouseTracker` component using Render Props:

```jsx
class MouseTracker extends React.Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (e) => {
    this.setState({ x: e.clientX, y: e.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove}>
        {this.props.render(this.state)}
      </div>
    );
  }
}

const App = () => (
  <MouseTracker render={({ x, y }) => (
    <h1>Mouse Position: {x}, {y}</h1>
  )} />
);

export default App;
```

Here, `MouseTracker` uses the `render` prop to dynamically display the mouse position.

---

It looks like I still haven’t completed the full series! Let's continue from where we left off and finish up with the rest of the ReactJS tutorial topics.

---

### 37. ReactJS - Render Props (Part 2)

- **Concepts Covered**:
 - Advanced techniques using Render Props to pass dynamic props to child components.
 - Using render props to handle dynamic content or actions (like fetching data).

- **Example**:
  Passing a dynamic prop to a child component using render props:

```jsx
class DataFetcher extends React.Component {
  state = { data: null };

  componentDidMount() {
    fetch(this.props.url)
      .then((response) => response.json())
      .then((data) => this.setState({ data }));
  }

  render() {
    return this.props.render(this.state.data);
  }
}

const App = () => (
  <DataFetcher url="https://jsonplaceholder.typicode.com/posts/1" render={(data) => (
    <div>
      <h1>{data ? data.title : 'Loading...'}</h1>
    </div>
  )} />
);

export default App;
```

In this case, `DataFetcher` fetches data and passes it to the child component through the render prop. The child component dynamically displays the data once it's fetched.

---

### 38. ReactJS - Context (Part 1)

- **Concepts Covered**:
 - Introduction to the React Context API.
 - Context is a way to share data (like a global state) across multiple components without passing props down manually through each level.

- **Example**:
  Using the Context API to share a theme across components:

```jsx
import React, { createContext, useState } from 'react';

// Create context
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => (
  <ThemeContext.Consumer>
    {({ theme, setTheme }) => (
      <div style={{ background: theme === 'dark' ? 'black' : 'white', color: theme === 'dark' ? 'white' : 'black' }}>
        <p>Current theme: {theme}</p>
        <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>Toggle Theme</button>
      </div>
    )}
  </ThemeContext.Consumer>
);

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);

export default App;
```

In this example, `ThemeContext` allows components to access and update the theme globally without prop drilling.

---

### 39. ReactJS - Context (Part 2)

- **Concepts Covered**:
 - Consuming context in functional components using the `useContext` hook.

- **Example**:
  Using `useContext` to access context values:

```jsx
import React, { createContext, useState, useContext } from 'react';

const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'dark' ? 'black' : 'white', color: theme === 'dark' ? 'white' : 'black' }}>
      <p>Current theme: {theme}</p>
      <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);

export default App;
```

`useContext` is a cleaner, modern way to access context values, replacing the `Consumer` component from the previous example.

---

### 40. ReactJS 0 - Context (Part 3)

- **Concepts Covered**:
 - Advanced context patterns: Updating context dynamically in a component.

- **Example**:
  Updating the context dynamically within a component:

```jsx
import React, { createContext, useState, useContext } from 'react';

const UserContext = createContext();

const UserProvider = ({ children }) => {
  const [user, setUser] = useState({ name: 'John Doe' });

  const updateUser = (newName) => setUser({ name: newName });

  return (
    <UserContext.Provider value={{ user, updateUser }}>
      {children}
    </UserContext.Provider>
  );
};

const Profile = () => {
  const { user, updateUser } = useContext(UserContext);
  return (
    <div>
      <p>Name: {user.name}</p>
      <button onClick={() => updateUser('Jane Smith')}>Change Name</button>
    </div>
  );
};

const App = () => (
  <UserProvider>
    <Profile />
  </UserProvider>
);

export default App;
```

Here, the `UserContext` allows multiple components to access and update the shared `user` state.

---

### 41. ReactJS 1 - HTTP and React

- **Concepts Covered**:
 - Making HTTP requests in React using `fetch` or `axios`.
 - Handling API requests to fetch data or send data.

- **Example**:
  Fetching data from an API using `fetch`:

```jsx
import React, { useState, useEffect } from 'react';

const App = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []);

  return (
    <div>
      {data ? <h1>{data.title}</h1> : <p>Loading...</p>}
    </div>
  );
};

export default App;
```

This example demonstrates how to fetch and display data from an API inside a React component.

---

### 42. ReactJS 2 - HTTP GET Request

- **Concepts Covered**:
 - Handling GET requests in React to retrieve data from a server or public API.

- **Example**:
  Making a GET request using `axios`:

```jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => setData(response.data));
  }, []);

  return (
    <div>
      {data ? <h1>{data.title}</h1> : <p>Loading...</p>}
    </div>
  );
};

export default App;
```

Here, we use `axios` to make an HTTP GET request and display the retrieved data.

---

### 43. ReactJS 3 - HTTP Post Request

- **Concepts Covered**:
 - Handling POST requests in React to send data to a server.

- **Example**:
  Sending data using a POST request with `axios`:

```jsx
import React, { useState } from 'react';
import axios from 'axios';

const App = () => {
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    axios.post('https://jsonplaceholder.typicode.com/posts', { name })
      .then((response) => {
        console.log('Data posted:', response.data);
      });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text" 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
        placeholder="Enter name" 
      />
      <button type="submit">Submit</button>
    </form>
  );
};

export default App;
```

This example sends a POST request with form data to an API using `axios`.

---

### **React Hooks Series**

---

#### 44. React Hooks - Introduction

- **Concepts Covered**:
 - Introduction to React Hooks, and why they were introduced.
 - Hooks provide a way to use state and lifecycle methods in functional components.
 - Hooks help simplify code by allowing components to manage state, side effects, and context without the need for class components.

- **Example**:
  Transition from a class component to a functional component using `useState`:

```jsx
// Before (class component)
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

// After (functional component with hooks)
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 45. React Hooks - useState Hook

- **Concepts Covered**:
 - Using the `useState` hook to add state to functional components.
 - `useState` returns an array: the current state value and a function to update it.

- **Example**: A simple counter app using `useState`.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 46. React Hooks - useState with Previous State

- **Concepts Covered**:
 - Updating state based on the previous state using `useState`.
 - It's important to use the callback version of the state setter function when updating based on the current state.

- **Example**: Incrementing the counter with the previous state value.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount((prevCount) => prevCount + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 47. React Hooks - useState with Object

- **Concepts Covered**:
 - Storing and updating objects using `useState`.
 - To update specific properties of an object, use the spread operator to maintain the previous state.

- **Example**: Updating user profile information stored as an object.

```jsx
const UserProfile = () => {
  const [user, setUser] = useState({ name: 'John', age: 30 });

  const updateName = () => setUser((prevUser) => ({ ...prevUser, name: 'Jane' }));

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <button onClick={updateName}>Change Name</button>
    </div>
  );
};
```

---

#### 48. React Hooks - useState with Array

- **Concepts Covered**:
 - Storing arrays in state and updating array items using `useState`.
 - When updating arrays, make sure to create a new array using methods like `concat`, `slice`, or spread operator.

- **Example**: Adding/removing items from a list.

```jsx
const TodoList = () => {
  const [todos, setTodos] = useState([]);

  const addTodo = () => {
    const newTodo = prompt('Enter a new todo');
    setTodos((prevTodos) => [...prevTodos, newTodo]);
  };

  const removeTodo = (index) => {
    setTodos((prevTodos) => prevTodos.filter((_, i) => i !== index));
  };

  return (
    <div>
      <ul>
        {todos.map((todo, index) => (
          <li key={index}>
            {todo} <button onClick={() => removeTodo(index)}>Delete</button>
          </li>
        ))}
      </ul>
      <button onClick={addTodo}>Add Todo</button>
    </div>
  );
};
```

---

#### 49. React Hooks - useEffect Hook

- **Concepts Covered**:
 - `useEffect` hook allows you to perform side effects (e.g., data fetching, subscriptions) in functional components.
 - Runs after the component renders.

- **Example**: Fetching data in `useEffect` on component mount.

```jsx
import { useState, useEffect } from 'react';

const DataFetcher = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []); // Empty dependency array means it only runs once when the component mounts

  return <div>{data ? <h1>{data.title}</h1> : 'Loading...'}</div>;
};
```

---

#### 50. React Hooks - useEffect after Render

- **Concepts Covered**:
 - Running `useEffect` after every render to monitor state or props changes.
 - Useful for debugging or when side effects depend on dynamic state.

- **Example**: Debugging component renders with `useEffect`.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Component rendered or count changed:', count);
  });

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 51. React Hooks - Conditionally Run Effects

- **Concepts Covered**:
 - You can conditionally run effects based on state or props changes by specifying dependencies in the dependency array of `useEffect`.

- **Example**: Fetching data when a particular state changes.

```jsx
const FetchOnChange = () => {
  const [query, setQuery] = useState('');
  const [data, setData] = useState(null);

  useEffect(() => {
    if (query) {
      fetch(`https://api.example.com/search?q=${query}`)
        .then((response) => response.json())
        .then((data) => setData(data));
    }
  }, [query]); // Runs when query changes

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <div>{data ? <pre>{JSON.stringify(data, null, 2)}</pre> : 'No results'}</div>
    </div>
  );
};
```

---

#### 52. React Hooks - Run Effects Only Once

- **Concepts Covered**:
 - You can run `useEffect` only once when the component mounts by passing an empty dependency array `[]`.

- **Example**: Setting up event listeners or fetching data once on component mount.

```jsx
const Component = () => {
  useEffect(() => {
    console.log('Component mounted');
    // Setup or fetch data here
  }, []); // Runs only once on mount

  return <div>Component</div>;
};
```

---

#### 53. React Hooks - useEffect with Cleanup

- **Concepts Covered**:
 - Cleaning up side effects when the component unmounts using the return function inside `useEffect`.

- **Example**: Cleaning up a timer or subscription in `useEffect`.

```jsx
const Timer = () => {
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Timer running...');
    }, 1000);

    return () => {
      clearInterval(timer); // Cleanup the timer on component unmount
    };
  }, []);

  return <div>Timer component</div>;
};
```

---

It seems like you want to continue the list from where we left off. Here's the continuation of the React Hooks tutorials:

---

#### 54. React Hooks - useEffect with Incorrect Dependency

- **Concepts Covered**:
 - Common mistakes when using `useEffect` with dependencies.
 - How missing or incorrectly added dependencies can lead to bugs, infinite loops, or stale data.

- **Example**: Debugging dependency arrays in `useEffect` by ensuring proper state and prop tracking.

```jsx
const ExampleComponent = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // Incorrect: Forgetting to add 'count' as a dependency could cause stale data issues
  useEffect(() => {
    console.log(`Name: ${name}`);
  }, []); // Should include 'count' if it is part of the effect

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <p>{name}</p>
      <button onClick={() => setName('John')}>Change Name</button>
    </div>
  );
};
```

---

#### 55. React Hooks - Fetching Data with useEffect Part 1

- **Concepts Covered**:
 - Using `useEffect` to fetch data from an API when the component mounts.
 - Handling API responses inside `useEffect`.

- **Example**: Fetching data from an API and displaying the fetched data.

```jsx
const DataFetcher = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((jsonData) => setData(jsonData));
  }, []); // Runs once after initial render

  return <div>{data ? <h1>{data.title}</h1> : 'Loading...'}</div>;
};
```

---

#### 56. React Hooks - Fetching Data with useEffect Part 2

- **Concepts Covered**:
 - Handling loading, success, and error states when fetching data with `useEffect`.

- **Example**: Conditional rendering for loading and error handling.

```jsx
const FetchDataWithState = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then((response) => response.json())
      .then((jsonData) => {
        setData(jsonData);
        setLoading(false);
      })
      .catch((error) => {
        setError(error);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{data && <h1>{data.title}</h1>}</div>;
};
```

---

#### 57. React Hooks - Fetching Data with useEffect Part 3

- **Concepts Covered**:
 - Optimizing multiple requests using `useEffect`.
 - Handling sequential or parallel API calls in `useEffect`.

- **Example**: Making multiple API requests simultaneously or sequentially.

```jsx
const FetchMultipleData = () => {
  const [posts, setPosts] = useState([]);
  const [user, setUser] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const postsRes = await fetch('https://jsonplaceholder.typicode.com/posts');
      const userRes = await fetch('https://jsonplaceholder.typicode.com/users/1');
      const postsData = await postsRes.json();
      const userData = await userRes.json();
      setPosts(postsData);
      setUser(userData);
    };

    fetchData();
  }, []);

  return (
    <div>
      {user && <h1>User: {user.name}</h1>}
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
};
```

---

#### 58. React Hooks - useContext Hook Part 1

- **Concepts Covered**:
 - Introduction to `useContext` for sharing global state across components.
 - Managing shared data like user authentication or theme state.

- **Example**: Sharing state between components using React Context.

```jsx
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  const toggleTheme = () => setTheme(theme === 'light' ? 'dark' : 'light');

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
      <p>The current theme is {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);
```

---

#### 59. React Hooks - useContext Hook Part 2

- **Concepts Covered**:
 - Updating context values dynamically and passing those values to components.

- **Example**: Changing theme (light/dark mode) across the app using context.

```jsx
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  const toggleTheme = () => setTheme((prev) => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'light' ? 'white' : 'gray', color: theme === 'light' ? 'black' : 'white' }}>
      <h1>Theme: {theme}</h1>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);
```

---

#### 60. React Hooks - useContext Hook Part 3

- **Concepts Covered**:
 - Combining `useContext` with other hooks like `useState` and `useEffect`.

- **Example**: Managing user authentication with `useContext`.

```jsx
const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  const login = (username) => setUser({ name: username });
  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

const UserProfile = () => {
  const { user, logout } = useContext(AuthContext);

  return user ? (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  ) : (
    <div>
      <p>Please login</p>
    </div>
  );
};

const App = () => (
  <AuthProvider>
    <UserProfile />
  </AuthProvider>
);
```

---

It seems like you're looking for more of the tutorial list. Here's the continuation from where we left off:

---

#### 61. React Hooks - useReducer Hook

- **Concepts Covered**:  
 - Introduction to `useReducer` for handling complex state logic.
 - When to use `useReducer` over `useState` for better control over state transitions.

- **Example**:  
 - Using `useReducer` to manage multi-step form logic or any complex state structure.

```jsx
const initialState = { step: 1, data: {} };

const formReducer = (state, action) => {
  switch (action.type) {
    case 'NEXT_STEP':
      return { ...state, step: state.step + 1 };
    case 'UPDATE_DATA':
      return { ...state, data: { ...state.data, ...action.payload } };
    default:
      return state;
  }
};

const FormComponent = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <h1>Step {state.step}</h1>
      <button onClick={() => dispatch({ type: 'NEXT_STEP' })}>Next Step</button>
      <button
        onClick={() =>
          dispatch({ type: 'UPDATE_DATA', payload: { name: 'John' } })
        }
      >
        Update Data
      </button>
    </div>
  );
};
```

---

#### 62. React Hooks - useReducer (Simple State & Action)

- **Concepts Covered**:  
 - Managing state transitions with `useReducer` for simple states and actions.

- **Example**:  
 - Implementing a simple counter with `useReducer`.

```jsx
const initialState = { count: 0 };

const counterReducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const CounterComponent = () => {
  const [state, dispatch] = useReducer(counterReducer, initialState);

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
    </div>
  );
};
```

---

#### 63. React Hooks - useReducer (Complex State & Action)

- **Concepts Covered**:  
 - Managing more complex states and actions with `useReducer`.

- **Example**:  
 - Using `useReducer` to handle form states with multiple inputs.

```jsx
const initialState = { name: '', email: '' };

const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    case 'UPDATE_EMAIL':
      return { ...state, email: action.payload };
    default:
      return state;
  }
};

const FormComponent = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  return (
    <div>
      <input
        type="text"
        value={state.name}
        onChange={(e) => dispatch({ type: 'UPDATE_NAME', payload: e.target.value })}
        placeholder="Name"
      />
      <input
        type="email"
        value={state.email}
        onChange={(e) => dispatch({ type: 'UPDATE_EMAIL', payload: e.target.value })}
        placeholder="Email"
      />
    </div>
  );
};
```

---

#### 64. React Hooks - Multiple useReducers

- **Concepts Covered**:  
 - Using multiple `useReducer` hooks within one component for separate pieces of state.

- **Example**:  
 - Combining two reducers for different pieces of state, such as managing a form and UI states.

```jsx
const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    default:
      return state;
  }
};

const uiReducer = (state, action) => {
  switch (action.type) {
    case 'TOGGLE_MODAL':
      return { ...state, showModal: !state.showModal };
    default:
      return state;
  }
};

const FormWithModal = () => {
  const [formState, dispatchForm] = useReducer(formReducer, { name: '' });
  const [uiState, dispatchUI] = useReducer(uiReducer, { showModal: false });

  return (
    <div>
      <input
        type="text"
        value={formState.name}
        onChange={(e) => dispatchForm({ type: 'UPDATE_NAME', payload: e.target.value })}
        placeholder="Name"
      />
      <button onClick={() => dispatchUI({ type: 'TOGGLE_MODAL' })}>
        Toggle Modal
      </button>
      {uiState.showModal && <div>Modal Content</div>}
    </div>
  );
};
```

---

#### 65. React Hooks - useReducer with useContext

- **Concepts Covered**:  
 - Combining `useReducer` with `useContext` to manage application-wide state.

- **Example**:  
 - Sharing form and UI states across components using both hooks.

```jsx
const StateContext = createContext();

const initialState = { name: '', showModal: false };

const reducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_NAME':
      return { ...state, name: action.payload };
    case 'TOGGLE_MODAL':
      return { ...state, showModal: !state.showModal };
    default:
      return state;
  }
};

const StateProvider = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <StateContext.Provider value={{ state, dispatch }}>
      {children}
    </StateContext.Provider>
  );
};

const NameInput = () => {
  const { state, dispatch } = useContext(StateContext);
  return (
    <input
      type="text"
      value={state.name}
      onChange={(e) => dispatch({ type: 'UPDATE_NAME', payload: e.target.value })}
      placeholder="Name"
    />
  );
};

const ModalToggle = () => {
  const { state, dispatch } = useContext(StateContext);
  return (
    <button onClick={() => dispatch({ type: 'TOGGLE_MODAL' })}>
      Toggle Modal
    </button>
  );
};

const App = () => (
  <StateProvider>
    <NameInput />
    <ModalToggle />
    {state.showModal && <div>Modal Content</div>}
  </StateProvider>
);
```

---

#### 66. React Hooks - Fetching Data with useReducer Part 1

- **Concepts Covered**:  
 - Using `useReducer` to manage fetching data and the associated loading, error, and success states.

- **Example**:  
 - Fetching data with complex state transitions (loading, error, success).

```jsx
const initialState = { loading: true, data: null, error: null };

const fetchReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { loading: false, data: action.payload, error: null };
    case 'FETCH_ERROR':
      return { loading: false, data: null, error: action.error };
    default:
      return state;
  }
};

const FetchDataComponent = () => {
  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts')
      .then((response) => response.json())
      .then((data) => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
      .catch((error) => dispatch({ type: 'FETCH_ERROR', error: error.message }));
  }, []);

  if (state.loading) return <div>Loading...</div>;
  if (state.error) return <div>Error: {state.error}</div>;

  return <ul>{state.data.map((post) => <li key={post.id}>{post.title}</li>)}</ul>;
};
```

---

It seems like you're still looking for more information from the list. I'll provide the continuation from where we left off:

---

#### 67. React Hooks - Fetching Data with useReducer Part 2

- **Concepts Covered**:  
 - Advanced error handling and optimization when using `useReducer` for fetching data.

- **Example**:  
 - Handling retries for failed fetch requests and managing multiple states (loading, success, error).

```jsx
const initialState = { loading: true, data: null, error: null, retryCount: 0 };

const fetchReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_SUCCESS':
      return { loading: false, data: action.payload, error: null, retryCount: 0 };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.error };
    case 'RETRY_FETCH':
      return { ...state, retryCount: state.retryCount + 1, loading: true };
    default:
      return state;
  }
};

const FetchDataWithRetry = () => {
  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() => {
    const fetchData = () => {
      fetch('https://jsonplaceholder.typicode.com/posts')
        .then((response) => response.json())
        .then((data) => dispatch({ type: 'FETCH_SUCCESS', payload: data }))
        .catch((error) => dispatch({ type: 'FETCH_ERROR', error: error.message }));
    };

    fetchData();
  }, [state.retryCount]);

  if (state.loading) return <div>Loading...</div>;
  if (state.error) {
    return (
      <div>
        Error: {state.error}
        <button onClick={() => dispatch({ type: 'RETRY_FETCH' })}>Retry</button>
      </div>
    );
  }

  return <ul>{state.data.map((post) => <li key={post.id}>{post.title}</li>)}</ul>;
};
```

---

#### 68. React Hooks - useState vs useReducer

- **Concepts Covered**:  
 - Comparing `useState` and `useReducer` for state management and when to use each.

- **Example**:  
 - Using `useState` for simple state management, and `useReducer` for complex state logic.

```jsx
// Using useState for simple state
const CounterWithState = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

// Using useReducer for complex state
const initialState = { count: 0, step: 1 };

const reducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + state.step };
    case 'SET_STEP':
      return { ...state, step: action.payload };
    default:
      return state;
  }
};

const CounterWithReducer = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'SET_STEP', payload: 2 })}>Set Step to 2</button>
    </div>
  );
};
```

---

#### 69. React Hooks - useCallback Hook

- **Concepts Covered**:  
 - Using `useCallback` to memoize functions and prevent unnecessary re-renders.
 - Optimizing performance by memoizing callbacks that are passed to child components.

- **Example**:  
 - Using `useCallback` to memoize a function for a button click handler.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return <ChildComponent increment={increment} />;
};

const ChildComponent = React.memo(({ increment }) => {
  console.log('Child component rendered');
  return <button onClick={increment}>Increment</button>;
});
```

---

#### 70. React Hooks - useMemo Hook

- **Concepts Covered**:  
 - Using `useMemo` to memoize expensive computations and avoid re-calculating on every render.

- **Example**:  
 - Optimizing complex calculations using `useMemo`.

```jsx
const ExpensiveComponent = ({ num }) => {
  const computeExpensiveValue = (num) => {
    console.log('Computing...');
    return num * 1000;
  };

  const memoizedValue = useMemo(() => computeExpensiveValue(num), [num]);

  return <div>Computed Value: {memoizedValue}</div>;
};
```

---

#### 71. React Hooks - useRef Hook Part 1

- **Concepts Covered**:  
 - Introduction to `useRef` for accessing DOM elements and storing mutable values that persist across renders.

- **Example**:  
 - Managing focus on an input element using `useRef`.

```jsx
const FocusInput = () => {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};
```

---

#### 72. React Hooks - useRef Hook Part 2

- **Concepts Covered**:  
 - Advanced usage of `useRef`, such as storing mutable values that persist across renders.

- **Example**:  
 - Storing a previous state value using `useRef`.

```jsx
const PreviousState = () => {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  return (
    <div>
      <h1>Current Count: {count}</h1>
      <h2>Previous Count: {prevCountRef.current}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 73. React Hooks - Custom Hooks

- **Concepts Covered**:  
 - Introduction to creating custom hooks to encapsulate reusable logic.

- **Example**:  
 - Creating a custom hook to handle window resizing.

```jsx
const useWindowSize = () => {
  const [size, setSize] = useState([window.innerWidth, window.innerHeight]);

  useEffect(() => {
    const handleResize = () => {
      setSize([window.innerWidth, window.innerHeight]);
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return size;
};

const WindowSizeComponent = () => {
  const [width, height] = useWindowSize();

  return (
    <div>
      <h1>Window Size</h1>
      <p>Width: {width}</p>
      <p>Height: {height}</p>
    </div>
  );
};
```

---

#### 74. React Hooks - useDocumentTitle Custom Hook

- **Concepts Covered**:  
 - Example of a custom hook to update the document title dynamically.

- **Example**:  
 - Creating a `useDocumentTitle` custom hook to change the page title.

```jsx
const useDocumentTitle = (title) => {
  useEffect(() => {
    document.title = title;
  }, [title]);
};

const PageComponent = () => {
  const [pageTitle, setPageTitle] = useState('Home');

  useDocumentTitle(pageTitle);

  return (
    <div>
      <h1>{pageTitle}</h1>
      <button onClick={() => setPageTitle('About')}>Change Title</button>
    </div>
  );
};
```

---

#### 75. React Hooks - useCounter Custom Hook

- **Concepts Covered**:  
 - Using a custom hook to manage counter logic.

- **Example**:  
 - Creating a reusable counter hook.

```jsx
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return { count, increment, decrement };
};

const CounterComponent = () => {
  const { count, increment, decrement } = useCounter(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};
```

---

#### 76. React Hooks - useInput

 Custom Hook

- **Concepts Covered**:  
 - Creating a custom hook to manage form input logic.

- **Example**:  
 - Reusable `useInput` hook to handle form input values.

```jsx
const useInput = (initialValue = '') => {
  const [value, setValue] = useState(initialValue);

  const handleChange = (e) => setValue(e.target.value);

  return { value, handleChange };
};

const FormComponent = () => {
  const nameInput = useInput('');
  const emailInput = useInput('');

  return (
    <form>
      <input {...nameInput} placeholder="Name" />
      <input {...emailInput} placeholder="Email" />
    </form>
  );
};
```

---

Here’s the continuation of your **React Render Series**:

---

#### 77. React Render - Introduction

- **Concepts Covered**:  
 - Introduction to React rendering behavior.
 - Understanding how React optimizes rendering and the concept of reconciliation.

- **Example**:  
 - Explaining the basic lifecycle of rendering and re-rendering in React components.

---

#### 78. React Render - Rendering

- **Concepts Covered**:  
 - How React renders UI and the process of creating a virtual DOM to optimize updates.
 - Reconciliation: React’s algorithm for matching updates to the virtual DOM with the actual DOM.

- **Example**:  
 - Rendering components in a React app and the process of state/prop change triggering a re-render.

```jsx
const MyComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 79. React Render - useState

- **Concepts Covered**:  
 - Understanding how `useState` triggers re-renders when state is updated.
 - The connection between state updates and component re-renders.

- **Example**:  
 - A counter app that demonstrates how `useState` causes the component to re-render on state change.

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Current count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 80. React Render - useReducer

- **Concepts Covered**:  
 - Exploring `useReducer` for managing more complex state logic.
 - Understanding how `useReducer` interacts with re-renders.

- **Example**:  
 - A simple counter with `useReducer`, showing how state updates lead to re-renders.

```jsx
const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const CounterWithReducer = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
    </div>
  );
};
```

---

#### 81. React Render - State Immutability

- **Concepts Covered**:  
 - Why state in React must be treated as immutable to ensure proper rendering behavior.
 - Best practices to ensure that React detects state changes.

- **Example**:  
 - Proper and improper ways to update state and how it affects re-renders.

```jsx
// Correct: using spread syntax to update an object
const [state, setState] = useState({ count: 0 });
const increment = () => setState((prevState) => ({ ...prevState, count: prevState.count + 1 }));

// Incorrect: mutating the state directly
const incrementWrong = () => state.count++;
```

---

#### 82. React Render - Parent and Child

- **Concepts Covered**:  
 - How re-renders in parent and child components work in React.
 - Optimizing performance when parent or child components re-render unnecessarily.

- **Example**:  
 - Parent component rendering with child components and handling unnecessary re-renders.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Parent Count: {count}</p>
      <ChildComponent />
      <button onClick={() => setCount(count + 1)}>Increment Parent</button>
    </div>
  );
};

const ChildComponent = React.memo(() => {
  return <div>Child Component</div>;
});
```

---

#### 83. React Render - Same Element Reference

- **Concepts Covered**:  
 - When React recognizes the same element reference and prevents unnecessary re-renders.
 - Understanding React's rendering optimizations.

- **Example**:  
 - Comparing cases where React can avoid re-rendering the same component with the same element reference.

```jsx
const Component = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      <button onClick={() => setValue(value + 1)}>Increment</button>
      {value > 5 && <p>Value is greater than 5</p>}
    </div>
  );
};
```

---

#### 84. React Render - React memo

- **Concepts Covered**:  
 - Using `React.memo` to memoize a component and prevent unnecessary re-renders.
 - How `React.memo` works and its effect on functional components.

- **Example**:  
 - Memoizing a component to prevent re-render when props don’t change.

```jsx
const ChildComponent = React.memo(({ name }) => {
  console.log('Child rendered');
  return <p>{name}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <ChildComponent name="John" />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 85. React Render - Questions on Optimization

- **Concepts Covered**:  
 - Common questions on React rendering optimizations, including unnecessary renders, memoization, and use of hooks.

- **Example**:  
 - Identifying when and where to optimize React components for performance.

```jsx
const MemoizedComponent = React.memo(({ value }) => {
  console.log('Rendered Memoized Component');
  return <p>{value}</p>;
});

const ParentComponent = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      <MemoizedComponent value={value} />
      <button onClick={() => setValue(value + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 86. React Render - Incorrect memo with children

- **Concepts Covered**:  
 - Potential issues with `React.memo` when used with child components that receive dynamic props.

- **Example**:  
 - A demonstration of how `React.memo` might not be effective when children receive new props on each render.

```jsx
const ChildComponent = React.memo(({ value }) => {
  console.log('Child rendered');
  return <p>{value}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const value = { id: 1 };

  return (
    <div>
      <ChildComponent value={value} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 87. React Render - Incorrect memo with Impure Component

- **Concepts Covered**:  
 - Why `React.memo` might not optimize performance for impure components that have side effects or rely on external states.

- **Example**:  
 - Using `React.memo` incorrectly with impure components.

```jsx
const ImpureComponent = ({ count }) => {
  console.log('Rendered Impure Component');
  return <p>{count}</p>;
};

const MemoizedImpureComponent = React.memo(ImpureComponent);

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <MemoizedImpureComponent count={count} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 88. React Render - Incorrect memo with props Reference

- **Concepts Covered**:  
 - Issues with `React.memo` when props are passed by reference (e.g., objects, arrays).

- **Example**:  
 - Demonstrating when React.memo will not prevent re-renders due to reference equality checks.

```jsx
const ChildComponent = React.memo(({ data }) => {
  console.log('Child rendered');
  return <p>{data.name}</p>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const data = { name: 'John' };

  return (
    <div>
      <ChildComponent data={data} />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

---

#### 89. React Render - useMemo and useCallback

- **Concepts Covered**:  
 - Using `

useMemo` and `useCallback` to memoize values and functions to optimize rendering.

- **Example**:  
 - Memoizing a callback function using `useCallback` and an expensive calculation with `useMemo`.

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const memoizedCallback = useCallback(() => {
    console.log('Memoized callback');
  }, []);

  const memoizedValue = useMemo(() => count * 2, [count]);

  return (
    <div>
      <p>Memoized Value: {memoizedValue}</p>
      <button onClick={memoizedCallback}>Memoized Callback</button>
    </div>
  );
};
```

---

#### 90. React Render - Context

- **Concepts Covered**:  
 - Understanding how Context affects re-renders in React components.
 - Avoiding unnecessary re-renders with Context.

- **Example**:  
 - Using `useContext` to access global state without causing re-renders in unrelated components.

```jsx
const ThemeContext = React.createContext();

const ParentComponent = () => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={theme}>
      <ChildComponent />
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>Toggle Theme</button>
    </ThemeContext.Provider>
  );
};

const ChildComponent = () => {
  const theme = useContext(ThemeContext);
  return <div>The theme is {theme}</div>;
};
```

---

#### 91. React Render - Context and memo

- **Concepts Covered**:  
 - Using `React.memo` with Context to prevent unnecessary re-renders.

- **Example**:  
 - Optimizing performance when combining `React.memo` and `useContext`.

```jsx
const MemoizedComponent = React.memo(() => {
  const theme = useContext(ThemeContext);
  return <div>Theme: {theme}</div>;
});
```

---

#### 92. React Render - Context and Same Element Reference

- **Concepts Covered**:  
 - How React re-renders components when the element reference remains the same, even in Context-based applications.

- **Example**:  
 - Understanding how `React.memo` and Context work together to avoid re-renders with unchanged references.

---

Here's the continuation of your **React TypeScript Series**:

---

#### 93. React TypeScript - Introduction

- **Concepts Covered**:  
 - Introduction to React with TypeScript.
 - Setting up TypeScript with a React project.
 - Benefits of using TypeScript in React: type safety, autocompletion, and easier refactoring.

- **Example**:  
 - Setting up a new React project with TypeScript using `create-react-app`.

```bash
npx create-react-app my-app --template typescript
```

---

#### 94. React TypeScript - Getting Started

- **Concepts Covered**:  
 - Getting started with TypeScript in React, and understanding the basics of type safety within JSX.
 - How TypeScript enhances React development by adding types to JSX components.

- **Example**:  
 - Writing a simple functional component in TypeScript.

```tsx
import React from 'react';

interface GreetingProps {
  name: string;
}

const Greeting: React.FC<GreetingProps> = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

export default Greeting;
```

---

#### 95. React TypeScript - Typing Props

- **Concepts Covered**:  
 - How to define types for props in TypeScript for React components.
 - Using interfaces to define the shape of props passed to functional components.

- **Example**:  
 - Typing props in a functional component using an interface.

```tsx
interface ButtonProps {
  label: string;
  onClick: () => void;
}

const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

---

#### 96. React TypeScript - Basic Props

- **Concepts Covered**:  
 - Basic prop types in React with TypeScript such as `string`, `number`, `boolean`, and `ReactNode`.
 - Understanding how to specify these basic types to ensure type safety.

- **Example**:  
 - Typing props with simple types like `string`, `number`, and `boolean`.

```tsx
interface CardProps {
  title: string;
  count: number;
  isVisible: boolean;
}

const Card: React.FC<CardProps> = ({ title, count, isVisible }) => {
  return isVisible ? (
    <div>
      <h2>{title}</h2>
      <p>{count}</p>
    </div>
  ) : null;
};
```

---

#### 97. React TypeScript - Advanced Props

- **Concepts Covered**:  
 - Advanced props such as optional props, default props, and function props.
 - How to make props optional or provide default values using TypeScript.

- **Example**:  
 - Typing components that accept function props or optional props.

```tsx
interface ButtonProps {
  onClick: () => void;
  color?: string;  // Optional prop
}

const Button: React.FC<ButtonProps> = ({ onClick, color = 'blue' }) => {
  return <button style={{ backgroundColor: color }} onClick={onClick}>Click me</button>;
};
```

---

#### 98. React TypeScript - Event Props

- **Concepts Covered**:  
 - Typing event props such as `onClick`, `onChange`, `onSubmit`, and others in React components.
 - Understanding how to type event handlers in TypeScript.

- **Example**:  
 - Typing `onClick` and `onChange` event handlers in a React component.

```tsx
interface FormProps {
  onSubmit: (value: string) => void;
}

const Form: React.FC<FormProps> = ({ onSubmit }) => {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(event.target.value);
  };

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    onSubmit(inputValue);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" value={inputValue} onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
};
```

---

#### 99. React TypeScript - Style Props

- **Concepts Covered**:  
 - Typing inline style props in React components using TypeScript.
 - Using the `CSSProperties` type from `react` for typing inline styles.

- **Example**:  
 - Typing the `style` attribute when applying inline styles to a component.

```tsx
import React, { CSSProperties } from 'react';

interface BoxProps {
  style?: CSSProperties;
}

const Box: React.FC<BoxProps> = ({ style }) => {
  return <div style={style}>This is a box!</div>;
};

// Usage
<Box style={{ backgroundColor: 'red', width: '100px', height: '100px' }} />
```

---

#### 100. React TypeScript - Prop Types and Tips

- **Concepts Covered**:  
 - Using `PropTypes` in addition to TypeScript for runtime prop validation.
 - Understanding the difference between static typing with TypeScript and runtime validation with PropTypes.

- **Example**:  
 - Combining TypeScript and PropTypes for validation of component props.

```tsx
import PropTypes from 'prop-types';

interface GreetingProps {
  name: string;
}

const Greeting: React.FC<GreetingProps> = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};

Greeting.propTypes = {
  name: PropTypes.string.isRequired
};

export default Greeting;
```

---

Here is the continuation of your **React TypeScript Series**:

---

#### 101. React TypeScript - useState Hook

- **Concepts Covered**:
 - Typing `useState` in TypeScript, handling different types of state, including primitive values, objects, and arrays.
 - Ensuring type safety for state variables, and understanding how TypeScript enhances the use of `useState`.

- **Example**:  
 - Defining types for state variables using `useState` with different types.

```tsx
import React, { useState } from 'react';

const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0);
  
  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

---

#### 102. React TypeScript - useState Future Value

- **Concepts Covered**:
 - Typing future state values and understanding asynchronous state updates.
 - Handling async logic in `useState`, such as when state is updated based on previous state values.

- **Example**:  
 - Handling async logic with `useState` in TypeScript.

```tsx
const [count, setCount] = useState<number>(0);

const incrementAsync = () => {
  setTimeout(() => {
    setCount(prev => prev + 1);
  }, 1000);
};
```

---

#### 103. React TypeScript - useState Type Assertion

- **Concepts Covered**:  
 - Using type assertions with `useState` to ensure specific types when TypeScript is unable to infer the type.
 - Casting state variables to a specific type to avoid errors or warnings.

- **Example**:  
 - Using type assertions to specify the type of state.

```tsx
const [value, setValue] = useState(''); // TypeScript infers value as string
const [count, setCount] = useState<number | null>(null);

setCount(5 as number); // Type assertion to tell TypeScript it's a number
```

---

#### 104. React TypeScript - useReducer Hook

- **Concepts Covered**:  
 - Typing the `useReducer` hook for more complex state logic, especially with action creators and state updates.
 - Using TypeScript with `useReducer` to ensure action and state types are strictly followed.

- **Example**:  
 - Managing state with `useReducer` and typing actions and state updates.

```tsx
interface State {
  count: number;
}

type Action = { type: 'increment' } | { type: 'decrement' };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const Counter: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
};
```

---

#### 105. React TypeScript - useReducer Strict Action Types

- **Concepts Covered**:  
 - Ensuring strict action types in `useReducer` to avoid accidentally passing in wrong action types and to improve type safety.

- **Example**:  
 - Making sure actions are strictly typed when using `useReducer`.

```tsx
type Action = 
  | { type: 'increment' }
  | { type: 'decrement' };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error('Unknown action type');
  }
};
```

---

#### 106. React TypeScript - useContext Hook

- **Concepts Covered**:  
 - Typing the `useContext` hook in TypeScript to ensure the context values are correctly typed and provide type safety for global state management.

- **Example**:  
 - Typing `useContext` with `createContext` to manage global state.

```tsx
interface ThemeContextProps {
  theme: string;
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextProps | undefined>(undefined);

const ThemeProvider: React.FC = ({ children }) => {
  const [theme, setTheme] = useState<string>('light');
  
  const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent: React.FC = () => {
  const context = useContext(ThemeContext);
  
  if (!context) {
    throw new Error('useContext must be used within a ThemeProvider');
  }
  
  return <div>{context.theme} mode</div>;
};
```

---

#### 107. React TypeScript - useContext Future Value

- **Concepts Covered**:  
 - Handling and typing async data inside `useContext` and managing dynamic values like API responses or future values.

- **Example**:  
 - Using `useContext` with asynchronous data.

```tsx
const DataContext = React.createContext<string | undefined>(undefined);

const DataProvider: React.FC = ({ children }) => {
  const [data, setData] = useState<string | undefined>(undefined);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    const response = await fetch('https://api.example.com/data');
    const result = await response.json();
    setData(result.data);
  };

  return <DataContext.Provider value={data}>{children}</DataContext.Provider>;
};
```

---

#### 108. React TypeScript - useRef Hook

- **Concepts Covered**:  
 - Typing the `useRef` hook in TypeScript to access DOM elements and manage mutable state.
 - Using `useRef` for direct DOM manipulation, while ensuring type safety.

- **Example**:  
 - Typing `useRef` to access DOM elements like input fields or divs.

```tsx
const InputFocus: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};
```

---

#### 109. React TypeScript - Class Component

- **Concepts Covered**:  
 - Typing class components in TypeScript, including the types for props, state, and methods.
 - How to work with TypeScript to type class component lifecycle methods.

- **Example**:  
 - A class-based component with typed props and state.

```tsx
interface CounterProps {
  initialCount: number;
}

interface CounterState {
  count: number;
}

class Counter extends React.Component<CounterProps, CounterState> {
  constructor(props: CounterProps) {
    super(props);
    this.state = { count: props.initialCount };
  }

  increment = () => {
    this.setState(prevState => ({ count: prevState.count + 1 }));
  };

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

---

#### 110. React TypeScript - Component Prop

- **Concepts Covered**:  
 - Defining and typing props in class components with TypeScript.
 - How to work with props in a typed class component.

- **Example**:  
 - A class-based component that receives props.

```tsx
interface ButtonProps {
  label: string;
}

class Button extends React.Component<ButtonProps> {
  render() {
    return <button>{this.props.label}</button>;
  }
}
```

---

Here’s the continuation of the **React TypeScript Series**:

---

#### 111. React TypeScript - Generic Props

- **Concepts Covered**:  
 - Using TypeScript generics for props to create reusable components with dynamic prop types.
 - How generics allow for flexibility and type safety when passing props to components.

- **Example**:  
 - A generic component that can accept props of any type.

```tsx
interface BoxProps<T> {
  value: T;
}

function Box<T>({ value }: BoxProps<T>) {
  return <div>{value}</div>;
}

// Using with different types
const App = () => (
  <>
    <Box value="Hello, world!" />
    <Box value={42} />
  </>
);
```

---

#### 112. React TypeScript - Restricting Props

- **Concepts Covered**:  
 - Restricting the type of props passed into a component using TypeScript.
 - Using union types, enums, or literal types to limit which types are allowed.

- **Example**:  
 - Creating stricter prop types to limit the allowed types.

```tsx
type ButtonProps = {
  color: 'primary' | 'secondary';  // Restricting to specific strings
  onClick: () => void;
};

const Button: React.FC<ButtonProps> = ({ color, onClick }) => (
  <button className={color} onClick={onClick}>
    Click me
  </button>
);
```

---

#### 113. React TypeScript - Template Literals and Exclude

- **Concepts Covered**:  
 - Using TypeScript’s `Exclude` utility type to manage types dynamically.
 - Combining template literals with `Exclude` to create flexible type constraints for props.

- **Example**:  
 - Dynamically restricting prop types using `Exclude` with template literals.

```tsx
type ButtonProps = {
  size: 'small' | 'medium' | 'large';
  color: 'red' | 'blue' | 'green';
};

type ExcludeSize = Exclude<ButtonProps['size'], 'small'>;

const Button: React.FC<ButtonProps> = ({ size, color }) => (
  <button style={{ fontSize: size === 'small' ? '12px' : '16px', color }}>
    Click me
  </button>
);
```

---

#### 114. React TypeScript - Wrapping HTML Elements

- **Concepts Covered**:  
 - Creating custom components that wrap around standard HTML elements while ensuring proper typing.
 - Using the `React.HTMLProps` interface to pass through standard props from a native HTML element.

- **Example**:  
 - Wrapping an HTML `div` element inside a custom component and typing the props.

```tsx
interface MyDivProps extends React.HTMLProps<HTMLDivElement> {
  customStyle: string;
}

const MyDiv: React.FC<MyDivProps> = ({ customStyle, ...props }) => {
  return <div style={{ backgroundColor: customStyle }} {...props} />;
};

// Usage
<MyDiv customStyle="lightblue" className="my-class">
  Content goes here
</MyDiv>;
```

---

#### 115. React TypeScript - Extracting a Component's Prop Types

- **Concepts Covered**:  
 - Extracting prop types from one component and reusing them in another component to ensure consistency.
 - Using `React.ComponentProps` to extract the types of props from a component.

- **Example**:  
 - Reusing prop types from another component using `React.ComponentProps`.

```tsx
const Button: React.FC<{ label: string }> = ({ label }) => <button>{label}</button>;

type ButtonProps = React.ComponentProps<typeof Button>;  // Extracts props from Button

const AnotherButton: React.FC<ButtonProps> = (props) => <button {...props} />;
```

---

#### 116. React TypeScript - Polymorphic Components

- **Concepts Covered**:  
 - Creating polymorphic components that can accept different types of HTML tags as children.
 - Typing polymorphic components using generics and React’s `as` prop to define the underlying HTML element.

- **Example**:  
 - A polymorphic button component that accepts different HTML tags as children.

```tsx
type ButtonProps<T extends React.ElementType> = {
  as?: T;
  children: React.ReactNode;
};

function Button<T extends React.ElementType = 'button'>({
  as,
  children,
}: ButtonProps<T>) {
  const Component = as || 'button'; // Default to 'button'
  return <Component>{children}</Component>;
}

// Usage
<Button as="a" href="https://example.com">
  Go to example
</Button>
<Button>Default Button</Button>
```

---

#### 117. React TypeScript - Wrapping up

- **Concepts Covered**:  
 - Wrapping up the series with final thoughts on how to use TypeScript effectively with React.
 - Best practices for combining React and TypeScript, improving developer experience, and maintaining type safety.

- **Example**:  
 - A summary of best practices and tips for React and TypeScript integration.

---

### Key React Concepts Covered Throughout the Series:
- **Functional vs Class Components**: Understanding the differences and when to use one over the other.
- **JSX (JavaScript XML)**: Using JavaScript syntax to create React elements.
- **Props and State**: Managing component data and how to pass data between components.
- **Event Handling**: Handling events in React and binding methods.
- **React Hooks**: Essential hooks like `useState`, `useEffect`, `useContext`, and `useReducer`.
- **Component Lifecycle**: How React components live, mount, and update.
- **Styling in React**: Using CSS and libraries like `styled-components` for styling.
- **Performance Optimization**: Using techniques like `React.memo`, `useCallback`, and `useMemo`.
- **TypeScript in React**: How to use TypeScript with React, typing props, state, and hooks.
- **Context API and State Management**: Managing global state efficiently across your application.
- **Custom Hooks**: How to create and use custom hooks to encapsulate business logic.

---

### **React, React-DOM, React-Scripts with CRA Template**

When creating a React project using **Create React App (CRA)**, several key dependencies are automatically installed to set up your development environment. These dependencies include `react`, `react-dom`, `react-scripts`, and `cra-template`. Let's explore each of these in detail.

---

### **1. `react`**

- **What it is**: `react` is the core library for building user interfaces. It provides the essential tools to create **components** and manage their state and lifecycle. React allows developers to build declarative, component-based UIs and is responsible for rendering the UI, managing components' states, and updating the virtual DOM when the state changes.
  
- **Key Concepts**:
  - **Components**: The fundamental building blocks of React apps. Components can either be **functional** (using hooks like `useState`, `useEffect`) or **class-based**.
  - **JSX**: React uses **JSX** (JavaScript XML), a syntax extension that allows you to write HTML-like code inside JavaScript functions.
  - **State & Props**: React uses **state** to manage data within components and **props** to pass data between components.

- **Why is it important**: `react` is the backbone of any React app, providing the necessary functionality to build dynamic UIs and manage the flow of data.

  **Example**: Basic React component:
  ```js
  import React, { useState } from 'react';

  function Counter() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <h1>Counter: {count}</h1>
        <button onClick={() => setCount(count + 1)}>Increase</button>
      </div>
    );
  }

  export default Counter;
  ```

---

### **2. `react-dom`**

- **What it is**: `react-dom` is the package that provides methods for DOM-related rendering. It's specifically used for rendering React components into the **actual DOM** in the browser. In a typical React application, React handles all the rendering logic, but `react-dom` interacts directly with the browser's DOM to update it as required.

- **Key Functions**:
  - **`ReactDOM.render()`**: This function is used to render a React component to the DOM. Typically, in newer versions of React, this is used in the `index.js` file of your app.
  - **`ReactDOM.createRoot()`**: In React 18 and beyond, React introduced concurrent rendering, and `createRoot()` is used to enable this new behavior.

- **Why is it important**: `react-dom` bridges the gap between React and the browser's DOM, allowing React components to be rendered into the webpage.

  **Example** (index.js):
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import App from './App';

  // Using ReactDOM.render (React 17 and earlier)
  // ReactDOM.render(<App />, document.getElementById('root'));

  // Using createRoot (React 18 and beyond)
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  ```

---

### **3. `react-scripts`**

- **What it is**: `react-scripts` is a package that contains all the default configurations and scripts needed to run a React project using Create React App (CRA). It abstracts away the configuration for tools like Webpack, Babel, ESLint, and others, so developers can focus on writing React code without needing to worry about the build setup.

- **Key Features**:
  - **Development Server**: Provides an easy-to-use development server that allows you to preview your app in the browser while you are developing.
  - **Build Scripts**: It offers scripts to build your project for production (`npm run build`), run tests (`npm run test`), and start the app in development mode (`npm start`).
  - **Webpack, Babel, ESLint, etc.**: These tools are pre-configured and optimized by `react-scripts` to bundle, transpile, and lint your React code.

- **Why is it important**: It simplifies the development experience by handling all the configuration, enabling developers to start building their app right away without needing to set up Webpack, Babel, or other tooling.

  **Common Commands**:
  - `npm start`: Starts the development server (typically at `http://localhost:3000`).
  - `npm run build`: Builds the app for production, optimizing assets for deployment.
  - `npm test`: Runs the tests using the configured testing framework (usually Jest).
  
  **Example**:
  ```bash
  npm start      # Starts the app in development mode
  npm run build  # Builds the production-ready app
  npm test       # Runs tests defined in the app
  ```

---

### **4. `cra-template` (or Custom Templates)**

- **What it is**: `cra-template` refers to the template that is used when creating a new project with Create React App. By default, `create-react-app` uses a template that sets up a basic React application. However, you can use custom templates for different purposes (e.g., TypeScript template, PWA template, etc.).

- **Common Templates**:
  - **`cra-template`**: The default template used for a regular JavaScript React application.
  - **`cra-template-typescript`**: A template for setting up a React project with TypeScript instead of JavaScript.
  - **Custom Templates**: Developers can create their own templates or use third-party templates.

- **Why is it important**: Templates give you a starting point for your React project. With `cra-template`, you get a fully set-up project that is ready for development, complete with all the necessary configurations, dependencies, and sample files.

  **Creating a React app with a template**:
  ```bash
  npx create-react-app my-app --template typescript   # For TypeScript template
  ```

  **The Default Template Structure**:
  When you create a new React app using `create-react-app`, the default template includes a standard file structure:
  ```
  my-app/
  ├── node_modules/
  ├── public/
  │   └── index.html
  ├── src/
  │   ├── App.css
  │   ├── App.js
  │   ├── index.css
  │   ├── index.js
  ├── .gitignore
  ├── package.json
  ├── README.md
  ```

---

### **Putting It All Together: How These Dependencies Work**

When you run `npx create-react-app my-app`, the following dependencies are installed in your project:

1. **`react`**: The core React library that enables you to create components and manage their state.
2. **`react-dom`**: The package that enables React to render components into the DOM and manage updates.
3. **`react-scripts`**: Provides the default scripts and configuration (e.g., Webpack, Babel) to run, build, and test your React app.
4. **`cra-template`**: The default template used to set up the basic structure and files of a React app.

These dependencies together make it easy to start a new React app without worrying about configuration details. Create React App simplifies the development experience and provides a smooth path for developers to start building their React applications.

---

### **Conclusion**

- `react`: The main library for building user interfaces with components.
- `react-dom`: Handles rendering React components to the browser’s DOM.
- `react-scripts`: Provides all the default build, start, and test configurations to run a React app.
- `cra-template`: The template used by Create React App to set up your project with a standard structure and configuration.

These tools, when used together, enable developers to quickly set up and start building React applications with minimal configuration.


### Example Concepts

1. **Using `useState` Hook**: 
   ```tsx
   import React, { useState } from 'react';

   const Counter: React.FC = () => {
     const [count, setCount] = useState<number>(0);

     return (
       <div>
         <h1>{count}</h1>
         <button onClick={() => setCount(count + 1)}>Increment</button>
       </div>
     );
   };

   export default Counter;
   ```

2. **Typing Props in TypeScript**:
   ```tsx
   type UserProps = {
     name: string;
     age: number;
   };

   const UserProfile: React.FC<UserProps> = ({ name, age }) => {
     return (
       <div>
         <h1>{name}</h1>
         <p>Age: {age}</p>
       </div>
     );
   };
   ```

3. **Using `useReducer` for Complex State**:
   ```tsx
   type State = { count: number };
   type Action = { type: 'increment' | 'decrement' };

   const reducer = (state: State, action: Action): State => {
     switch (action.type) {
       case 'increment':
         return { count: state.count + 1 };
       case 'decrement':
         return { count: state.count - 1 };
       default:
         return state;
     }
   };

   const Counter: React.FC = () => {
     const [state, dispatch] = useReducer(reducer, { count: 0 });

     return (
       <div>
         <h1>{state.count}</h1>
         <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
         <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
       </div>
     );
   };
   ```

4. **Creating a Custom Hook (`useLocalStorage`)**:
   ```tsx
   import { useState } from 'react';

   function useLocalStorage<T>(key: string, initialValue: T) {
     const storedValue = localStorage.getItem(key);
     const parsedValue = storedValue ? JSON.parse(storedValue) : initialValue;

     const [value, setValue] = useState<T>(parsedValue);

     const setStoredValue = (newValue: T) => {
       setValue(newValue);
       localStorage.setItem(key, JSON.stringify(newValue));
     };

     return [value, setStoredValue] as const;
   }
   ```

---
Providing **examples and code for all 117 tutorials** in a single message would be too lengthy and could overwhelm the context. However, I can break this down by key topics and provide a few code examples for the core concepts covered in the **Codevolution React Series**. Here's an overview with code examples for each section:

---

### **ReactJS Series Examples**

1. **Introduction to React**  
   - **Concept**: React is a JavaScript library for building user interfaces.
   - **Example**: Creating your first React app using `create-react-app`.

   ```bash
   npx create-react-app my-app
   cd my-app
   npm start
   ```

2. **Hello World**  
   - **Concept**: Basic React rendering using JSX.
   - **Example**:

   ```jsx
   import React from 'react';

   const App = () => {
     return <h1>Hello, World!</h1>;
   };

   export default App;
   ```

3. **JSX (JavaScript XML)**  
   - **Concept**: JSX allows you to write HTML-like code inside JavaScript.
   - **Example**:

   ```jsx
   const App = () => {
     const greeting = "Hello, World!";
     return <div>{greeting}</div>;
   };
   ```

4. **Props**  
   - **Concept**: Props are used to pass data from parent to child components.
   - **Example**:

   ```jsx
   const WelcomeMessage = ({ name }) => {
     return <h1>Welcome, {name}!</h1>;
   };

   const App = () => {
     return <WelcomeMessage name="John" />;
   };
   ```

5. **State**  
   - **Concept**: State represents data or variables that can change in a component.
   - **Example**:

   ```jsx
   import React, { useState } from 'react';

   const Counter = () => {
     const [count, setCount] = useState(0);

     return (
       <div>
         <h1>{count}</h1>
         <button onClick={() => setCount(count + 1)}>Increment</button>
       </div>
     );
   };

   export default Counter;
   ```

6. **Component Lifecycle Methods**  
   - **Concept**: Methods that run at different stages of a component's lifecycle (Mounting, Updating, Unmounting).
   - **Example** (using class components):

   ```jsx
   import React, { Component } from 'react';

   class App extends Component {
     componentDidMount() {
       console.log('Component mounted!');
     }

     componentDidUpdate() {
       console.log('Component updated!');
     }

     render() {
       return <h1>React Lifecycle Methods</h1>;
     }
   }

   export default App;
   ```

---

### **React Hooks Series Examples**

1. **useState Hook**  
   - **Concept**: Hook for adding state to functional components.
   - **Example**:

   ```jsx
   import React, { useState } from 'react';

   const Counter = () => {
     const [count, setCount] = useState(0);

     return (
       <div>
         <h1>{count}</h1>
         <button onClick={() => setCount(count + 1)}>Increment</button>
       </div>
     );
   };

   export default Counter;
   ```

2. **useEffect Hook**  
   - **Concept**: Hook for running side-effects in functional components (e.g., fetching data, subscriptions).
   - **Example**:

   ```jsx
   import React, { useState, useEffect } from 'react';

   const DataFetching = () => {
     const [data, setData] = useState(null);

     useEffect(() => {
       fetch('https://jsonplaceholder.typicode.com/posts')
         .then((response) => response.json())
         .then((data) => setData(data));
     }, []);

     return (
       <div>
         <h1>Data</h1>
         {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}
       </div>
     );
   };

   export default DataFetching;
   ```

3. **useReducer Hook**  
   - **Concept**: Hook for managing more complex state logic (similar to `useState` but more powerful).
   - **Example**:

   ```jsx
   import React, { useReducer } from 'react';

   const initialState = { count: 0 };

   const reducer = (state, action) => {
     switch (action.type) {
       case 'increment':
         return { count: state.count + 1 };
       case 'decrement':
         return { count: state.count - 1 };
       default:
         return state;
     }
   };

   const Counter = () => {
     const [state, dispatch] = useReducer(reducer, initialState);

     return (
       <div>
         <h1>{state.count}</h1>
         <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
         <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
       </div>
     );
   };

   export default Counter;
   ```

4. **useContext Hook**  
   - **Concept**: Hook for sharing state globally in the component tree without prop drilling.
   - **Example**:

   ```jsx
   import React, { useState, useContext, createContext } from 'react';

   const ThemeContext = createContext();

   const ThemeProvider = ({ children }) => {
     const [theme, setTheme] = useState('light');
     return (
       <ThemeContext.Provider value={{ theme, setTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   };

   const ThemedComponent = () => {
     const { theme, setTheme } = useContext(ThemeContext);
     return (
       <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
         <h1>Current Theme: {theme}</h1>
         <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>Toggle Theme</button>
       </div>
     );
   };

   const App = () => {
     return (
       <ThemeProvider>
         <ThemedComponent />
       </ThemeProvider>
     );
   };

   export default App;
   ```

---

### **React with TypeScript Series Examples**

1. **Typing Props**  
   - **Concept**: TypeScript allows you to specify the types of props passed to a component.
   - **Example**:

   ```tsx
   type WelcomeProps = {
     name: string;
   };

   const Welcome: React.FC<WelcomeProps> = ({ name }) => {
     return <h1>Hello, {name}!</h1>;
   };

   const App = () => {
     return <Welcome name="John" />;
   };

   export default App;
   ```

2. **Typing useState with TypeScript**  
   - **Concept**: Using TypeScript to type the state when using `useState`.
   - **Example**:

   ```tsx
   import React, { useState } from 'react';

   const Counter: React.FC = () => {
     const [count, setCount] = useState<number>(0);

     return (
       <div>
         <h1>{count}</h1>
         <button onClick={() => setCount(count + 1)}>Increment</button>
       </div>
     );
   };

   export default Counter;
   ```

3. **useReducer with TypeScript**  
   - **Concept**: Using `useReducer` with TypeScript for more complex state management.
   - **Example**:

   ```tsx
   type State = { count: number };
   type Action = { type: 'increment' | 'decrement' };

   const reducer = (state: State, action: Action): State => {
     switch (action.type) {
       case 'increment':
         return { count: state.count + 1 };
       case 'decrement':
         return { count: state.count - 1 };
       default:
         return state;
     }
   };

   const Counter: React.FC = () => {
     const [state, dispatch] = useReducer(reducer, { count: 0 });

     return (
       <div>
         <h1>{state.count}</h1>
         <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
         <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
       </div>
     );
   };

   export default Counter;
   ```

---

### Wrapping Up

The **Codevolution React series** covers a broad range of topics from **basic React concepts** to **advanced patterns** like **Higher Order Components**, **render props**, **React hooks**, and **TypeScript integration**. Each tutorial builds on the previous one, enabling you to learn step by step. You can implement these concepts and gradually improve your React and TypeScript skills with real-world applications.
